<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>‚≠ê SK's Bubble Shooter</title>
    <link id="dynamicFavicon" rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>‚≠ê</text></svg>">
    <style>

        @font-face {
            font-family: 'Storopia';
            src: url('./fonts/Storopia.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
        }
@keyframes tickPulse {
    0% {
        text-shadow: 0 0 0 rgba(255, 80, 80, 0);
        transform: scale(1);
    }
    50% {
        text-shadow: 0 0 18px rgba(255, 80, 80, 0.9);
        transform: scale(1.08);
    }
    100% {
        text-shadow: 0 0 0 rgba(255, 80, 80, 0);
        transform: scale(1);
    }
}

.tick-pulse {
    animation: tickPulse 0.25s ease-out;
}



.tick-pulse {
    animation: tickPulse 0.25s ease-out;
}
        /* Apply font globally */
        body, button, input, span, div, p, h1, h2, #debugConsole, #debugInput {
            font-family: 'Storopia', sans-serif;
        }

        body {
            background: #1a1a1a;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

            .game-container {
                position: relative;
                width: 100%;
                display: flex;
                justify-content: center;
            }

            canvas {
                background: #000;
                border: 4px solid #333;
                box-shadow: 0 0 20px rgba(0,0,0,0.5);
                display: none;
                cursor: cell;
            }
.menuDescription {
    margin-top: 14px;
    font-family: Storopia;
    font-size: 14px;
    color: #cccccc;
    text-align: center;
    min-height: 32px; /* prevents layout jump */
}

            .menu, .ui {
                margin: 10px;
                text-align: center;
                width: 100%;
                max-width: 600px;
            }

            button {
                padding: 10px 20px;
                cursor: pointer;
                background: #444;
                color: white;
                border: none;
                border-radius: 5px;
                margin: 5px;
                transition: 0.2s;
                font-weight: bold;
            }

                button:hover {
                    background: #00ffcc;
                    color: #000;
                }

            .back-btn {
                background: #ff5555;
            }

            #fileInput {
                display: none;
            }

            #mobileControls {
                position: absolute;
                top: 140px; /* adjust if you want */
                left: 50%;
                transform: translateX(240px); /* ‚úÖ puts it to the RIGHT of centered canvas */
                display: none;
                flex-direction: column;
                gap: 10px;
            }

            .mobile-btn {
                width: 60px;
                height: 60px;
                border-radius: 50%;
                background: #333;
                border: 2px solid #555;
                font-size: 0.8em;
                padding: 5px;
                color: white;
            }

                .mobile-btn:active {
                    background: #00ffcc;
                    color: #000;
                }

        #debugConsole {
            display: none;
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            max-width: 400px;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #00ffcc;
            padding: 10px;
            z-index: 1000;
            border-radius: 5px;
            font-family: 'Storopia', monospace;
        }

        #debugInput {
            width: 100%;
            background: #000;
            color: #00ffcc;
            border: 1px solid #333;
            padding: 5px;
            font-family: 'Storopia', monospace;
            outline: none;
        }
            /* Centered Progress & Streak Bars */
            .bars-container {
                display: flex;
                flex-direction: column;
                align-items: center;
                width: 100%;
                margin-bottom: 10px;
                position: relative;
            }

            .progress-wrapper {
                display: flex;
                align-items: center;
                justify-content: center;
                width: 100%;
                position: relative;
            }

            #progressContainer {
                width: 400px;
                height: 12px;
                background: #333;
                border-radius: 6px;
                display: none;
                overflow: hidden;
                border: 1px solid #444;
            }

            #progressBar {
                height: 100%;
                width: 0%;
                background: linear-gradient(90deg, #00ffcc, #00e5ff);
                transition: width 0.3s ease;
            }

            #percentText {
                font-weight: bold;
                color: #00ffcc;
                position: absolute;
                left: calc(50% + 210px);
                display: none;
                white-space: nowrap;
            }

            #streakContainer {
                width: 300px;
                height: 6px;
                background: #222;
                border-radius: 3px;
                display: none;
                overflow: hidden;
                border: 1px solid #333;
                margin-top: 5px;
            }

            #streakBar {
                height: 100%;
                width: 0%;
                background: #00e5ff;
                box-shadow: 0 0 8px #00e5ff;
                transition: width 0.1s linear;
            }

            #customUI {
                display: none;
                text-align: center;
                margin: 10px;
                background: #222;
                padding: 15px;
                border-radius: 10px;
                border: 1px solid #444;
            }

            .palette-btn {
                width: 30px;
                height: 30px;
                border-radius: 50%;
                cursor: pointer;
                display: inline-block;
                margin: 5px;
                border: 2px solid #333;
            }

                .palette-btn.active {
                    border: 3px solid white;
                    box-shadow: 0 0 10px white;
                    transform: scale(1.1);
                }

            .ammo-input {
                background: #000;
                color: #00ffcc;
                border: 1px solid #444;
                padding: 5px;
                width: 50px;
                text-align: center;
                border-radius: 4px;
                font-weight: bold;
            }

            #soundToggle {
                background: #555;
            }

            #autosaveToggle {
                background: #444;
            }
            #campaignTimerDisplay {
    position: absolute;
    top: 5000%;
    left: 100.5%;
    transform: translate(-50%, -50%);

    color: #66ff00;
    font-weight: bold;
    font-family: Storopia;
    font-size: 50px;

    pointer-events: none; /* clicks go through */
    display: none;
}
    </style>
</head>
<body oncontextmenu="return false;">

    <div class="menu" id="mainMenu">
        <h1>SK's Bubble Shooter</h1>
        <p>Made by SK1768 :)</p>
        <button onclick="startPuzzleMode()" style="font-size: 1.5em; background: #00ffcc; color: #000;" onmouseenter="setMenuDesc('Puzzle Mode: Clear all bubbles using limited ammo.')" onmouseleave="clearMenuDesc()">PUZZLE MODE</button>
        <br>
        <button onclick="enterCustomEditor()" style="background: #a155ff;"onmouseenter="setMenuDesc('Custom Mode: Create and test your own bubble layouts.')" onmouseleave="clearMenuDesc()">CUSTOM MODE</button>
        <br>
        <button id="autosaveToggle" onclick="toggleAutosave()" onmouseenter="setMenuDesc('Autosave: Creates a save file every time you complete a level in Puzzle Mode.')" onmouseleave="clearMenuDesc()">üíæ Autosave: OFF</button>
        <button id="soundToggle" onclick="toggleSound()" onmouseenter="setMenuDesc('Sound: Toggles the in game\'s sound. Note: SFX Tester will not play any sound effects when the sound is off.')" onmouseleave="clearMenuDesc()">üîä Sound: ON</button>
        <br>
        <button onclick="startCampaign()" style="background:#ff9500; font-weight:bold;"onmouseenter="setMenuDesc('Campaign Mode: Beat 20 levels before the timer runs out.')" onmouseleave="clearMenuDesc()">
            üèÜ CAMPAIGN MODE
        </button>
        <button
    onclick="resetStats()"
    style="margin-top:10px; background:#ff5555; color:#000; font-weight:bold;"
    onmouseenter="setMenuDesc('Resets ALL saved stats. This cannot be undone.')"
    onmouseleave="clearMenuDesc()"
>
    üóëÔ∏è RESET STATS
</button>
		<div id="menuDescription" class="menuDescription">
</div>
		<h3 style="margin-top:0;text-align:center;">üìä Player Stats</h3>
		<div id="statsBoard" style="
    margin:15px auto;
    padding:15px;
    background:#111;
    border:2px solid #00ffcc;
    border-radius:10px;
    color:#00ffcc;
    font-size:14px;
    max-width:360px;
    box-shadow:0 0 20px rgba(0,255,204,0.15);
">
    <div id="statsContent"></div>
</div>
<br>
    <div id="customUI">
        <div style="margin-bottom: 10px;">
            <button class="back-btn" onclick="exitToMenu()">‚Üê MENU</button>
            <span style="color:#a155ff; font-weight:bold; margin: 0 15px;">LEVEL CREATOR</span>
            <button onclick="clearEditor()" style="background:#cc3300;">CLEAR ALL</button>
            <button onclick="document.getElementById('fileInput').click()" style="background:#2196F3;">LOAD FILE</button>
            <button onclick="openCustomSavePopup()" style="background:#4CAF50;">SAVE FILE</button>
        </div>
        <div style="background: #333; padding: 10px; border-radius: 5px; display: inline-block;">
            <label>Set Ammo: </label>
            <input type="number" id="customAmmoInput" class="ammo-input" value="40" min="1">
            <button onclick="startFromCustom()" style="background:#00ffcc; color:#000;">PLAY TEST</button>
        </div>
        <div id="colorPalette" style="margin-top: 10px;"></div>
    </div>

  
    <div id="debugConsole">
        <input type="text" id="debugInput" placeholder="Enter a command...">
    </div>

    <div id="gameUI" class="ui" style="display:none">
        <div class="bars-container">
            <div class="progress-wrapper">
                <div id="progressContainer"><div id="progressBar"></div>
            <span id="campaignTimerDisplay">
    <span id="campaignTimerInner">05:00</span>
</span>

            </div>
                <span id="percentText">0.0%</span>
            </div>
            <div id="streakContainer"><div id="streakBar"></div></div>
        </div>
        <button class="back-btn" onclick="exitToMenu()">‚Üê MENU</button> |
        <button onclick="saveGame()" style="background:#4CAF50;">SAVE</button>
        <button id="loadBtn" onclick="handleLoadClick()" style="background:#2196F3;">LOAD</button>
|
        <button id="pauseBtn" onclick="togglePause()" style="background:#ffcc00; color:#000;">PAUSE</button><br><br>
        <span id="levelDisplay">Level: 1</span> |
        <span id="ammoDisplay" style="color:#ffcc00; font-weight:bold;">Bubbles: 0</span> |
        <span id="scoreDisplay">Score: 0</span> |
        <span id="streakDisplay" style="color:#00e5ff; font-weight:bold;">Streak: x1</span>

    </div>

    <div class="game-container">
        <canvas id="gameCanvas" width="440" height="640"></canvas>
        <div id="mobileControls">
    <button class="mobile-btn" onclick="swapBubbles()">SWAP</button>
    <button class="mobile-btn" id="debugBtn" onclick="openDebug()">DEBUG</button>

    <!-- NEW: moved here -->
    <button class="mobile-btn" id="colorblindToggle" onclick="toggleColorblind()">üëÅÔ∏è</button>
    <button class="mobile-btn" id="aimToggle" onclick="toggleAim()">üéØ</button>
</div>
    </div>

    <input type="file" id="fileInput" accept=".bubblesav" onchange="loadGame(event)">

<script>
    // ======================
// PLAYER STATS SYSTEM
// ======================

const DEFAULT_STATS = {
    levelsCompleted: 0,
    levelsFailed: 0,
    campaignWins: 0,

    bubblesShot: 0,
    bubblesSwapped: 0,
	bubblesPopped: 0,
	bubblesDropped: 0,

    totalStreak: 0,
    perfectStreak: 0,

    puzzlePlays: 0,
    campaignPlays: 0,
    customPlays: 0,

    debugCommandsUsed: 0,
	
    totalScore: 0,
};

function loadStats() {
    const saved = localStorage.getItem("bubbleShooterStats");
    return saved ? JSON.parse(saved) : { ...DEFAULT_STATS };
}

function saveStats() {
    localStorage.setItem("bubbleShooterStats", JSON.stringify(stats));
}

let stats = loadStats();
	window.addEventListener("DOMContentLoaded", updateStatsBoard);
    window.addEventListener('DOMContentLoaded', () => {
        console.log(
            "%cWelcome to SK's Bubble Shooter HTML game!",
            "color: #00ffcc; font-size: 16px; font-weight: bold;"
        );
    });

function resetStats() {
    const ok = confirm(
        "Reset ALL player stats?\n\n" +
        "This will erase:\n" +
        "‚Ä¢ Level completions & failures\n" +
        "‚Ä¢ Campaign wins\n" +
        "‚Ä¢ Scores & streaks\n\n" +
        "This cannot be undone."
    );

    if (!ok) return;

    stats = { ...DEFAULT_STATS };
    saveStats();
    updateStatsBoard();

    console.log("Player stats reset.");
}
    document.fonts.load("20px Storopia");
    // --- SETTINGS & AUDIO ---
let soundEnabled = localStorage.getItem('bubbleSoundEnabled') !== 'false'; 
let autosaveEnabled = localStorage.getItem('bubbleAutosaveEnabled') === 'true';
    let customLevelName = "";
    let isLoadingSave = false;
const PERFECT_BASE_SCORE = 1000;
const PERFECT_AMMO_BONUS = 100;
let customAuthorName = "";
let isCampaignMode = false;
    let campaignLevel = 1;
    let campaignTimer = 0;
    const COLORLESS_CHANCE = 0.10;
    let lastTickSecond = null;
    let lastTimeMs = performance.now();
    let campaignTimerAcc = 0; // accumulator for 1-second ticks (optional)
    const CAMPAIGN_TOTAL_LEVELS = 20;
    let loadedProgressOverride = null;
    const CAMPAIGN_TIME_LIMIT = 300; // 5 minutes in seconds
    const COLORLESS = null;
let levelPattern = 0;
    let panicMode = false;
let panicFlash = false;
let panicTimer = 0;
  let panicTriggered = false;  
  let mouseX = 0;
let mouseY = 0;
let aimEnabled = localStorage.getItem('bubbleAimEnabled') !== 'false';
let lastShotBubbleCount = 0;
let campaignFinished = false;
let lastShotWasMatch = false;
let lastShotUsedFinalAmmo = false;
let lastClearWasPerfect = false;
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

function setBrowserTitle(text) {
    document.title = text;
}

function setMenuDesc(text) {
    document.getElementById('menuDescription').innerText = text;
}

function clearMenuDesc() {
    document.getElementById('menuDescription').innerText =
        "";
}
    function updateStatsBoard() {
    const el = document.getElementById("statsContent");
    if (!el) return;

    el.innerHTML = `
    Levels Completed: <b>${fmt(stats.levelsCompleted)}</b><br>
    Levels Failed: <b>${fmt(stats.levelsFailed)}</b><br>
    Campaign Wins: <b>${fmt(stats.campaignWins)}</b><br><br>

    Bubbles Shot: <b>${fmt(stats.bubblesShot)}</b><br>
    Bubbles Swapped: <b>${fmt(stats.bubblesSwapped)}</b><br>
	Bubbles Popped: <b>${fmt(stats.bubblesPopped)}</b><br>
	Bubbles Dropped: <b>${fmt(stats.bubblesDropped)}</b><br><br>

    Max Streak: <b>${fmt(stats.totalStreak)}</b><br>
    Max Perfect Streak: <b>${fmt(stats.perfectStreak)}</b><br><br>

    Puzzle Mode Played: <b>${fmt(stats.puzzlePlays)}</b><br>
    Campaign Mode Played: <b>${fmt(stats.campaignPlays)}</b><br>
    Custom Mode Played: <b>${fmt(stats.customPlays)}</b><br><br>

    Debug Commands Used: <b>${fmt(stats.debugCommandsUsed)}</b><br><br>
	
    Total Score: <b>${fmt(stats.totalScore)}</b>
    `;
}
function updateSoundButton() {
    const btn = document.getElementById('soundToggle');
    if(btn) {
        btn.innerText = soundEnabled ? "üîä Sound: ON" : "üîá Sound: OFF";
        btn.style.background = soundEnabled ? "#555" : "#333";
    }
}
    
function updateAutosaveButton() {
    const btn = document.getElementById('autosaveToggle');
    if(btn) {
        btn.innerText = autosaveEnabled ? "üíæ Autosave: ON" : "üíæ Autosave: OFF";
        btn.style.background = autosaveEnabled ? "#4CAF50" : "#444";
    }
}

function addSfxButtonToMenu() {
    const menu = document.getElementById('mainMenu');
    if (document.getElementById('sfxMenuBtn')) return;

    const btn = document.createElement('button');
    btn.id = 'sfxMenuBtn';
    btn.innerText = 'üéµ SFX TESTER';
    btn.style.background = '#00e5ff';
    btn.style.color = '#000';
    btn.style.fontWeight = 'bold';

    btn.onclick = openSfxMenu;
    btn.onmouseenter = () =>
        setMenuDesc("SFX Tester: Opens a menu to test in-game sound effects.");
    btn.onmouseleave = clearMenuDesc;

    menu.appendChild(document.createElement('br'));
    menu.appendChild(btn);
}

function toggleSound() {
    soundEnabled = !soundEnabled;
    localStorage.setItem('bubbleSoundEnabled', soundEnabled);
    updateSoundButton();
}

function toggleAutosave() {
    autosaveEnabled = !autosaveEnabled;
    localStorage.setItem('bubbleAutosaveEnabled', autosaveEnabled);
    updateAutosaveButton();
}

updateSoundButton();
updateAutosaveButton();
updateAimButton();


function toggleAim() {
    aimEnabled = !aimEnabled;
    localStorage.setItem('bubbleAimEnabled', aimEnabled);
    updateAimButton();
}

function updateAimButton() {
    const btn = document.getElementById('aimToggle');
    if (!btn) return;
    btn.innerText = aimEnabled ? "üéØ ON" : "üéØ OFF";
    btn.style.borderColor = aimEnabled ? "#00ffcc" : "#555";
}

const sounds = {
    play(type) {
        if (!soundEnabled) return;
        if (audioCtx.state === 'suspended') audioCtx.resume();

        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain);
        gain.connect(audioCtx.destination);

        const now = audioCtx.currentTime;

        if (type === 'shoot') {
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(150, now);
            osc.frequency.exponentialRampToValueAtTime(40, now + 0.1);
            gain.gain.setValueAtTime(0.1, now);
            gain.gain.linearRampToValueAtTime(0, now + 0.1);
            osc.start(); osc.stop(now + 0.1);

        } else if (type === 'pop') {
    osc.type = 'triangle';                 // soft but punchy
    osc.frequency.setValueAtTime(700, now);
    osc.frequency.exponentialRampToValueAtTime(80, now + 0.07);

    gain.gain.setValueAtTime(0.12, now);
    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.07);

    osc.start();
    osc.stop(now + 0.07);

        } else if (type === 'bounce') {
            osc.type = 'sine';
            osc.frequency.setValueAtTime(200, now);
            gain.gain.setValueAtTime(0.05, now);
            gain.gain.linearRampToValueAtTime(0, now + 0.05);
            osc.start(); osc.stop(now + 0.05);

        } else if (type === 'place') {
            osc.type = 'sine';
            osc.frequency.setValueAtTime(100, now);
            gain.gain.setValueAtTime(0.1, now);
            gain.gain.linearRampToValueAtTime(0, now + 0.08);
            osc.start(); osc.stop(now + 0.08);

        } else if (type === 'swap') {
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(300, now);
            osc.frequency.linearRampToValueAtTime(600, now + 0.05);
            gain.gain.setValueAtTime(0.05, now);
            gain.gain.linearRampToValueAtTime(0, now + 0.05);
            osc.start(); osc.stop(now + 0.05);

        } else if (type === 'fall') {
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(100, now);
            osc.frequency.linearRampToValueAtTime(20, now + 0.3);
            gain.gain.setValueAtTime(0.05, now);
            gain.gain.linearRampToValueAtTime(0, now + 0.3);
            osc.start(); osc.stop(now + 0.3);

        } else if (type === 'win') {
            [440, 554, 659, 880].forEach((f, i) => {
                const o = audioCtx.createOscillator();
                const g = audioCtx.createGain();
                o.connect(g); g.connect(audioCtx.destination);
                o.frequency.setValueAtTime(f, now + i * 0.1);
                g.gain.setValueAtTime(0.08, now + i * 0.1);
                g.gain.linearRampToValueAtTime(0, now + i * 0.4);
                o.start(now + i * 0.1);
                o.stop(now + i * 0.4);
            });

        } else if (type === 'fail') {
            osc.type = 'square';
            osc.frequency.setValueAtTime(100, now);
            osc.frequency.linearRampToValueAtTime(30, now + 0.5);
            gain.gain.setValueAtTime(0.1, now);
            gain.gain.linearRampToValueAtTime(0, now + 0.5);
            osc.start(); osc.stop(now + 0.5);

         } else if (type === 'panic') {
    osc.type = 'sine';                     // softer waveform
    osc.frequency.setValueAtTime(650, now); // less piercing
    gain.gain.setValueAtTime(0.025, now);  // WAY quieter
    gain.gain.linearRampToValueAtTime(0, now + 0.18);
    osc.start();
    osc.stop(now + 0.18);
}
    else if (type === 'tick') {
        osc.type = 'square';
        osc.frequency.setValueAtTime(800, now);
        gain.gain.setValueAtTime(0.03, now);
        gain.gain.linearRampToValueAtTime(0, now + 0.08);
        osc.start();
        osc.stop(now + 0.08);
    }

    }
};
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

const RADIUS = 20;
const ROW_HEIGHT = 34;
const DEADLINE = 520;

const ALL_COLORS = [
    '#FF0000', // strong red
    '#FF9500', // orange
    '#FFCC00', // yellow
    '#34C759', // green
    '#00C7BE', // teal
    '#007AFF', // blue
    '#5856D6', // indigo
    '#AF52DE', // purple
    '#FF2D55', // pink
    '#8E8E93', // grey
    '#A2845E', // brown (visible, not muddy)
    '#FFFFFF'  // white
];

const COLOR_EMOJIS = {
    '#FF0000': 'üî¥',
    '#FF9500': 'üü†',
    '#FFCC00': 'üü°',
    '#34C759': 'üü¢',
    '#00C7BE': 'üîµ',
    '#007AFF': 'üî∑',
    '#5856D6': 'üü£',
    '#AF52DE': 'üü™',
    '#FF2D55': 'üíó',
    '#8E8E93': '‚ö™',
    '#A2845E': 'üü§',
    '#FFFFFF': '‚¨ú'
};


let mode = 'puzzle', score = 0, level = 1, angle = 0, mouseInside = false;
let bubbles = [], fallingBubbles = [], projectiles = [], particles = [], floatingScores = [], confetti = [];
let currentBall = '', nextBall = '', ammo = 0, initialBubbleCount = 0;
let streakCount = 1, streakTimer = 0, streakFrozen = false;
const STREAK_DURATION = 180;
let gameOver = false, gameWin = false, gameRunning = false, isPaused = false;
let gameOverReason = ""; 
let animationId = null, isCustomMode = false, isPlaytesting = false, customLevelSnapshot = [];
let selectedColor = ALL_COLORS[0];
let perfectStreak = 0;

function updateFavicon(color) {
    const favicon = document.getElementById('dynamicFavicon');

    const svgIcon =
        `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100">
            <circle cx="50" cy="50" r="45"
                fill="${color}"
                stroke="white"
                stroke-width="8"/>
        </svg>`;

    favicon.href = 'data:image/svg+xml,' + encodeURIComponent(svgIcon);
}
    
    function setFaviconEmoji(emoji) {
    const favicon = document.getElementById('dynamicFavicon');
    favicon.href =
        'data:image/svg+xml,' +
        '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100">' +
        `<text y=".9em" font-size="90">${emoji}</text>` +
        '</svg>#' + Math.random(); // force refresh
}
function startCampaign() {
        stats.campaignPlays++;
        saveStats();
        setBrowserTitle("üèÜ SK's Bubble Shooter ‚Äî Campaign Mode");
        isCampaignMode = true;
        campaignLevel = 1;
        campaignTimer = CAMPAIGN_TIME_LIMIT;
        lastTimeMs = performance.now(); // ‚úÖ reset timer baseline
        startMode('puzzle');
    }

function refreshFavicon() {

    if (gameWin) {
        setFaviconEmoji("‚úÖ");
        return;
    }

    if (gameOver) {
        setFaviconEmoji("‚ùå");
        return;
    }

    if (isPaused) {
        setFaviconEmoji("‚è∏Ô∏è");
        return;
    }

    if (panicMode) {
        setFaviconEmoji("‚ö†Ô∏è");
        return;
    }

    updateFavicon(currentBall);
}
    
function updatePanicState() {
    if (isPaused || isCustomMode || gameOver || gameWin) {
        panicMode = false;
        panicTriggered = false;
        refreshFavicon();
        return;
    }

    const nearRedLine = bubbles.some(b => b.y > DEADLINE - 60);
    const lowAmmo = ammo < 10;

    const shouldPanic = nearRedLine || lowAmmo;

    if (shouldPanic && !panicMode) {
        // entering panic
        panicMode = true;
        if (!panicTriggered) {
            sounds.play('panic');   // plays once
            panicTriggered = true;
        }
        refreshFavicon();
        return;
    }

    if (!shouldPanic && panicMode) {
        // leaving panic
        panicMode = false;
        panicTriggered = false;
        refreshFavicon();
    }
}
function openDebug() { document.getElementById('debugConsole').style.display = 'block'; document.getElementById('debugInput').value = ''; document.getElementById('debugInput').focus(); setPause(true); }

window.addEventListener('keydown', e => {
    if (e.key === 'Escape') togglePause();
    if (e.ctrlKey && e.shiftKey && e.key.toLowerCase() === 'c') { e.preventDefault(); openDebug(); }
});

document.getElementById('debugInput').addEventListener('keydown', e => {
    if (e.key === 'Enter') {
	stats.debugCommandsUsed++;
    saveStats();
        const input = e.target.value.trim().toLowerCase();
        const args = input.split(' ');
        const cmd = args[0];
        const val = parseInt(args[1]);

        if (cmd === '!completelevel') { 
            bubbles = []; 
            triggerWin(); 
        } 
        else if (cmd === '!setammo' && !isNaN(val)) { 
            ammo = val; 
        } 
        else if (cmd === '!setstreak' && !isNaN(val)) { 
            streakCount = val; 
            streakTimer = STREAK_DURATION; 
        } 
        else if (cmd === '!freezestreaktimer') { 
            streakFrozen = true; 
        }
        else if (cmd === '!unfreezestreaktimer') { 
            streakFrozen = false; 
        }
        else if (cmd === '!faillevel') {
            triggerFail("You used the !faillevel debug command.");
        }
        else if (cmd === '!advancelevel' && !isNaN(val)) {
            level = val;
            startMode('puzzle', false, true);
        }

        else if (cmd === '!advancecampaignlevel' && !isNaN(val)) {

            if (!isCampaignMode) {
                alert("You must be in campaign mode to use this command.");
                return;
            }

            // üöÄ If value is ABOVE max ‚Üí instantly win campaign
            if (val > CAMPAIGN_TOTAL_LEVELS) {

                campaignLevel = CAMPAIGN_TOTAL_LEVELS + 1;
                campaignTimer = 0;
                lastTickSecond = null;

                gameWin = true;
                isCampaignMode = false;

                sounds.play('win');
                refreshFavicon();

                return;
            }

            // üîí Clamp between 1 and max
            const target = Math.max(1, Math.min(CAMPAIGN_TOTAL_LEVELS, val));

            // üéÅ Reward ammo like normal campaign clear
            ammo += 20;

            campaignLevel = target;
            campaignTimer = CAMPAIGN_TIME_LIMIT;
            lastTickSecond = null;

            // Load that campaign stage
            startMode('puzzle', false, true);
        }
else if (cmd === '!setperfectstreak' && !isNaN(val)) {
    perfectStreak = Math.max(0, val);
    console.log(`Perfect streak set to x${perfectStreak}`);
}

else if (cmd === '!addcampaigntime' && !isNaN(val)) {

    if (!isCampaignMode) {
        alert("You must be in campaign mode to use this command.");
        return;
    }

    // ‚è±Ô∏è Add seconds (can be negative)
    campaignTimer += val;

    // üîí Clamp so it never goes below 0
    if (campaignTimer < 0) {
        campaignTimer = 0;
    }

    // üîî Reset tick state so warning sounds/glow resync properly
    lastTickSecond = null;

    console.log(`Campaign time adjusted by ${val}s. New time: ${Math.ceil(campaignTimer)}s`);
}

        e.target.value = '';
        document.getElementById('debugConsole').style.display = 'none';
        setPause(false);
    }
});

window.addEventListener('mousemove', e => {
    const rect = canvas.getBoundingClientRect();
    mouseX = e.clientX - rect.left;
    mouseY = e.clientY - rect.top;

    angle = Math.atan2(
        mouseY - (canvas.height - 80),
        mouseX - (canvas.width / 2)
    );
});


let colorblindMode = localStorage.getItem('bubbleColorblind') === 'true';

function updateColorblindButton() {
    const btn = document.getElementById('colorblindToggle');
    if (!btn) return;
    btn.innerText = colorblindMode ? "üëÅÔ∏è ON" : "üëÅÔ∏è OFF";
    btn.style.borderColor = colorblindMode ? "#00ffcc" : "#555";
}


function toggleColorblind() {
    colorblindMode = !colorblindMode;
    localStorage.setItem('bubbleColorblind', colorblindMode);
    updateColorblindButton();
}

updateColorblindButton();

canvas.addEventListener('mousedown', e => {
    // Right-click: swap
    if (e.button === 2) {
        e.preventDefault();
        swapBubbles();
        return false;
    }

    const rect = canvas.getBoundingClientRect();

    // -----------------------------
    // CUSTOM EDITOR CLICK BEHAVIOR
    // -----------------------------
    if (isCustomMode) {
        let r = Math.round((e.clientY - rect.top - RADIUS) / ROW_HEIGHT);
        let off = (r % 2 === 0) ? 0 : RADIUS;
        let c = Math.round((e.clientX - rect.left - RADIUS - off) / (RADIUS * 2));

        const idx = bubbles.findIndex(b => b.row === r && b.col === c);

        // Click existing bubble = remove it
        if (idx !== -1) {
            bubbles.splice(idx, 1);
        }
        // Click empty spot = place it (limit rows)
        else if (r >= 0 && r < 13) {
            let co = getGridCoords(r, c);

            // If you want "true colorless" like your save file (missing color field),
            // do NOT store color when selectedColor is null.
            const bubble = { x: co.x, y: co.y, row: r, col: c };
            if (selectedColor) bubble.color = selectedColor; // only store when colored

            bubbles.push(bubble);
        }

        // IMPORTANT: stop here so editor clicks do NOT shoot / advance levels
        return;
    }

    // -----------------------------
    // NORMAL GAME CLICK BEHAVIOR
    // -----------------------------
    if (!gameRunning) return;

    if (isPaused) {
        setPause(false);
        return;
    }

    // If level ended, click advances (your existing logic)
    if (gameOver || gameWin) {

        if (isPlaytesting) {
            bubbles = JSON.parse(JSON.stringify(customLevelSnapshot));
            enterCustomEditor();
            return;
        }

        if (gameWin) {

            if (isCampaignMode) {

                if (campaignLevel >= CAMPAIGN_TOTAL_LEVELS) {
                    isCampaignMode = false;
                    campaignLevel = 1;
                    return;
                }

                campaignLevel++;
                campaignTimer = 300;

                startMode('puzzle', false, true);

                // reward ammo AFTER new level loads
                ammo += 20;
                updateAmmo();
                return;
            }

            level++;
            startMode('puzzle', false, true);
            return;
        }

        if (gameOver) {

            if (isCampaignMode)
        {
            campaignTimer = CAMPAIGN_TIME_LIMIT;
        }
            score = 0;
            startMode('puzzle');
            return;
        }
    }

    // only allow shooting when cursor is valid (same rule as aim visualiser)
    if (
        mouseX >= 0 &&
        mouseX <= canvas.width &&
        mouseY >= 0 &&
        mouseY <= DEADLINE
    ) {
        shoot();
    }
});
function setPause(state) {
    isPaused = state;
    document.getElementById('pauseBtn').innerText = isPaused ? "RESUME" : "PAUSE";
    refreshFavicon();
}
function togglePause() { if(!gameRunning || gameOver || gameWin) return; setPause(!isPaused); }

function shoot() {
   loadedProgressOverride = null;

     // üîí Freeze shot conditions
    lastShotWasMatch = false;
    lastShotUsedFinalAmmo = (ammo === 1);
    lastShotBubbleCount = bubbles.length;

    if (projectiles.length > 0 || ammo <= 0) return;
    sounds.play('shoot');

    projectiles.push({
        x: canvas.width / 2,
        y: canvas.height - 80,
        dx: Math.cos(angle) * 12,
        dy: Math.sin(angle) * 12,
        color: currentBall
    });

    ammo--;
    currentBall = nextBall;
    stats.bubblesShot++;
saveStats();
    updateAmmo(true); // ‚úÖ ONLY here do we reroll next
}
function snapToGrid(p) {
    p.x -= p.dx * 0.5;
    p.y -= p.dy * 0.5;

    let r = Math.max(0, Math.round((p.y - RADIUS) / ROW_HEIGHT));
    let off = (r % 2 === 0) ? 0 : RADIUS;

    let c = Math.max(
        0,
        Math.min(
            (r % 2 === 0 ? 10 : 9),
            Math.round((p.x - RADIUS - off) / (RADIUS * 2))
        )
    );

    let co = getGridCoords(r, c);

    if (bubbles.some(b => b.row === r && b.col === c)) {
        r++;
        co = getGridCoords(r, c);
    }

    const nb = {
        x: co.x,
        y: co.y,
        row: r,
        col: c,
        color: p.color
    };

    bubbles.push(nb);

let m = findMatches(nb);

if (m.length >= 3) {
    lastShotWasMatch = true; // ‚úÖ mark match
    streakCount++;
    streakTimer = STREAK_DURATION;
    popBubbles(m);
} else {
    lastShotWasMatch = false;
        sounds.play('place');
        if (ammo <= 0 && bubbles.length > 0)
            triggerFail("You ran out of bubbles!");

const beforePct = calcProgressPercent(bubbles.length - 1, initialBubbleCount); 
// bubbles.length already includes the newly placed bubble, so -1 = before placement

updateProgressBar();

const afterPct = calcProgressPercent(bubbles.length, initialBubbleCount);
const diff = +(afterPct - beforePct).toFixed(1);

floatingScores.push({
    x: p.x,
    y: p.y,
    text: `${diff > 0 ? '+' : ''}${diff.toFixed(1)}%`,
    life: 1.0
});


    }
}
function calcProgressPercent(currentCount, initialCount) {
    if (initialCount <= 0) return 100;
    const pct = (Math.max(0, initialCount - currentCount) / initialCount) * 100;
    return +pct.toFixed(1);
}

function popBubbles(m) {
    const beforePct = calcProgressPercent(bubbles.length, initialBubbleCount);

    sounds.play('pop');
	stats.bubblesPopped += m.length;
    saveStats();
    let pts = m.length * 10 * streakCount;
    score += pts;

    m.forEach(b => {
        let idx = bubbles.indexOf(b);
        if (idx > -1) bubbles.splice(idx, 1);

        for (let i = 0; i < 6; i++) {
            particles.push({
                x: b.x, y: b.y,
                vx: (Math.random()-0.5)*8,
                vy: (Math.random()-0.5)*8,
                life: 1.0,
                color: b.color,
                size: Math.random()*3+1
            });
        }
    });

    dropFloatingBubbles();
    updateProgressBar();

    const afterPct = calcProgressPercent(bubbles.length, initialBubbleCount);
    const diff = +(afterPct - beforePct).toFixed(1);

    floatingScores.push({
        x: m[0]?.x || 220,
        y: m[0]?.y || 320,
        text: `+${fmt(pts)} x${fmt(streakCount)}  (${diff > 0 ? '+' : ''}${diff.toFixed(1)}%)`,
        life: 1.0
		
    });

if (bubbles.length === 0) {
    triggerWin();
}


 else if (ammo <= 0) triggerFail("You ran out of bubbles!");
 updateAmmo();
 lastShotWasMatch = false;
}

function fmt(n) {
    return Number(n).toLocaleString();
}

function triggerWin() {

        if (isCampaignMode) {

            // FINAL LEVEL
            if (campaignLevel >= CAMPAIGN_TOTAL_LEVELS) {

                campaignFinished = true;
                gameWin = true;
     	        stats.campaignWins++;
                saveStats();

               triggerConfetti();
                triggerConfetti();
                sounds.play('win');
                refreshFavicon();
							if (score > stats.totalScore) {
    stats.totalScore = score;
}
                return;
            }

            // Normal campaign level clear
            gameWin = true;
            sounds.play('win');
            triggerConfetti();
            refreshFavicon();
            return;
			if (score > stats.totalScore) {
    stats.totalScore = score;
}
        }

saveStats();
// üéØ PERFECT = last ammo + match + clears board
lastClearWasPerfect =
    lastShotUsedFinalAmmo &&
    lastShotWasMatch &&
    lastShotBubbleCount > 0;

if (
    lastClearWasPerfect &&
    mode !== "custom" &&
    !isPlaytesting
) {
    perfectStreak++;

    const bonusScore = PERFECT_BASE_SCORE * perfectStreak;
    score += bonusScore;
    ammo += PERFECT_AMMO_BONUS;
} else {
    perfectStreak = 0;
}
    stats.levelsCompleted++;
stats.totalStreak = Math.max(stats.totalStreak, streakCount);
stats.perfectStreak = Math.max(stats.perfectStreak, perfectStreak);
	if (score > stats.totalScore) {
    stats.totalScore = score;
}
saveStats();
        gameWin = true;
        sounds.play('win');
        triggerConfetti();
        refreshFavicon();
    }

function triggerFail(reason) {

        gameOver = true;
        gameOverReason = reason;
        sounds.play('fail');
		       perfectStreak = 0;
        refreshFavicon();
        
stats.levelsFailed++;
saveStats();

        if (isCampaignMode) {
            hideCampaignTimer();
            campaignLevel = 1;
        }
    }

function getProgress() {
    const pct = initialBubbleCount > 0 ? (Math.max(0, initialBubbleCount - bubbles.length) / initialBubbleCount) * 100 : 100;
    return pct.toFixed(1) + "%";
}

function updateProgressBar() {

    let progressStr;

    if (loadedProgressOverride !== null) {
        progressStr = loadedProgressOverride;
    } else {
        progressStr = getProgress();
    }

    document.getElementById('progressBar').style.width = progressStr;
    document.getElementById('percentText').innerText = progressStr;
}

function update() {
    // ---- delta time (seconds) ----
const nowMs = performance.now();
const dt = (nowMs - lastTimeMs) / 1000;
lastTimeMs = nowMs;

if (isCampaignMode && !isPaused && !gameOver && !gameWin) {

        campaignTimer -= dt;


// use DISPLAYED time for logic
const secondsLeft = Math.ceil(campaignTimer);

if (secondsLeft <= -1) {
    triggerFail("You ran out of time!");
    campaignLevel = 1;
}

        // üî• Ticking sound under 10 seconds
        if (secondsLeft <= 10 && secondsLeft > -1) {

            if (lastTickSecond !== secondsLeft) {
                sounds.play('tick');
const inner = document.getElementById('campaignTimerInner');
if (inner) {
    inner.classList.remove('tick-pulse');
    void inner.offsetWidth; // force reflow
    inner.classList.add('tick-pulse');
}


                lastTickSecond = secondsLeft;
            }

        } else {
            lastTickSecond = null;
        }
    }



    if (isPaused || isCustomMode) return;
    updatePanicState();
    if (!gameOver && !gameWin) {
        if (streakTimer > 0 && !streakFrozen) { 
            streakTimer--; 
            if (streakTimer <= 0) streakCount = 1; 
        }
        const streakPct = (streakTimer / STREAK_DURATION) * 100;
        document.getElementById('streakBar').style.width = (streakCount > 1 ? streakPct : 0) + "%";

        projectiles.forEach((p, i) => {
            particles.push({ x: p.x, y: p.y, vx: (Math.random()-0.5)*2, vy: (Math.random()-0.5)*2, life: 0.5, color: p.color, size: Math.random()*4+2 });
            p.x += p.dx; p.y += p.dy;
            if (p.x < RADIUS || p.x > canvas.width - RADIUS) { p.dx *= -1; sounds.play('bounce'); }
            if (p.y < RADIUS) { snapToGrid(p); projectiles.splice(i, 1); }
            else { for (let b of bubbles) { if (Math.hypot(p.x - b.x, p.y - b.y) < RADIUS * 1.5) { snapToGrid(p); projectiles.splice(i, 1); break; } } }
        });
        bubbles.forEach(b => { if (b.y > DEADLINE) triggerFail("You hit the red line!"); });
    }
    particles.forEach((p, i) => { p.x += p.vx; p.y += p.vy; p.life -= 0.03; if (p.life <= 0) particles.splice(i, 1); });
    fallingBubbles.forEach((fb, i) => { fb.y += 4; if (fb.y > canvas.height + 20) fallingBubbles.splice(i, 1); });
    floatingScores.forEach((fs, i) => { fs.y -= 1; fs.life -= 0.01; if (fs.life <= 0) floatingScores.splice(i, 1); });
    confetti.forEach((c, i) => { c.x += c.vx; c.y += c.vy; c.vy += 0.2; c.life -= 0.01; if (c.life <= 0) confetti.splice(i, 1); });
}

 function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.strokeStyle = '#ff3333'; ctx.setLineDash([5, 5]);
    ctx.beginPath(); ctx.moveTo(0, DEADLINE); ctx.lineTo(canvas.width, DEADLINE); ctx.stroke(); ctx.setLineDash([]);
    bubbles.forEach(b => {
    // COLORLESS bubble = outline only
    if (!b.color) {
        ctx.strokeStyle = "#ffffff";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(b.x, b.y, RADIUS - 2, 0, Math.PI * 2);
        ctx.stroke();
        return;
    }

    // Normal colored bubble
    ctx.fillStyle = b.color;
    ctx.beginPath();
    ctx.arc(b.x, b.y, RADIUS - 2, 0, Math.PI * 2);
    ctx.fill();

    // Colorblind emoji overlay (only for colored bubbles)
    if (colorblindMode) {
        ctx.fillStyle = "black";
        ctx.font = "16px Storopia";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(COLOR_EMOJIS[b.color] || '‚ùî', b.x, b.y);
    }
});


    if (!isCustomMode) {
        ctx.save();
        fallingBubbles.forEach(fb => { ctx.globalAlpha = 0.5; ctx.fillStyle = fb.color; ctx.beginPath(); ctx.arc(fb.x, fb.y, RADIUS - 2, 0, Math.PI * 2); ctx.fill(); });
        particles.forEach(p => { ctx.globalAlpha = p.life; ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2); ctx.fill(); });
        // ---- Floating score text ----
        ctx.save();
        floatingScores.forEach(fs => {
            ctx.globalAlpha = fs.life;
            ctx.fillStyle = "#00ffcc";
            ctx.font = "bold 20px Storopia";
            ctx.textAlign = "center";
            ctx.fillText(fs.text, fs.x, fs.y);
        });
        ctx.restore();
        confetti.forEach(c => { ctx.globalAlpha = c.life; ctx.fillStyle = c.color; ctx.fillRect(c.x, c.y, 5, 5); });
        ctx.restore();
        projectiles.forEach(p => {
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, RADIUS - 2, 0, Math.PI * 2);
            ctx.fill();
        });

        drawAimVisualizer(); // ‚úÖ TOP LAYER ‚Äî now visible

        if (!isPaused && ammo > 0) {

            // ---- CURRENT BALL ----
            ctx.fillStyle = currentBall;
            ctx.beginPath();
            ctx.arc(canvas.width / 2, canvas.height - 80, RADIUS, 0, Math.PI * 2);
            ctx.fill();

            if (colorblindMode) {
                ctx.fillStyle = "black";
                ctx.font = "20px Storopia";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText(
                    COLOR_EMOJIS[currentBall] || '‚ùî',
                    canvas.width / 2,
                    canvas.height - 80
                );
            }

            // ---- NEXT BALL ----
            if (ammo > 1) {
                ctx.fillStyle = nextBall;
                ctx.beginPath();
                ctx.arc(canvas.width / 2 + 60, canvas.height - 80, RADIUS * 0.7, 0, Math.PI * 2);
                ctx.fill();
		
                if (colorblindMode) {
                    ctx.fillStyle = "black";
                    ctx.font = "16px Storopia";
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    ctx.fillText(
                        COLOR_EMOJIS[nextBall] || '‚ùî',
                        canvas.width / 2 + 60,
                        canvas.height - 80
                    );
                }
            }
        }

        if (isPaused) {
            ctx.fillStyle = "rgba(0,0,0,0.6)"; ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = "#ffcc00"; ctx.textAlign = "center"; ctx.font = "bold 40px Storopia"; ctx.fillText("GAME PAUSED", 220, 320);
        }
        if (gameOver || gameWin) {
    ctx.fillStyle = "rgba(0,0,0,0.85)";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.textAlign = "center";

    // --- CAMPAIGN FINISHED SCREEN ---
    if (campaignFinished) {
        ctx.fillStyle = "#00ffcc";

        ctx.font = "bold 36px Storopia";
        ctx.fillText("CONGRATULATIONS!", canvas.width / 2, 250);

        ctx.font = "22px Storopia";
        ctx.fillText("You've beaten Campaign Mode!", canvas.width / 2, 300);

        ctx.fillStyle = "#FFFFFF";
        ctx.font = "16px Storopia";
        ctx.fillText("Click to continue", canvas.width / 2, 340);
    }

    // --- PERFECT WIN SCREEN ---
    else if (!gameOver && lastClearWasPerfect) {
        ctx.fillStyle = "#FFD700";
        ctx.shadowColor = "#FFD700";
        ctx.shadowBlur = 12;

        ctx.font = "bold 40px Storopia";
        ctx.fillText("PERFECT!", canvas.width / 2, 260);

        ctx.shadowBlur = 0;

        ctx.font = "bold 20px Storopia";
        ctx.fillText("+1,000 SCORE  +100 BUBBLES", canvas.width / 2, 295);

        ctx.fillStyle = "#FFFFFF";
        ctx.font = "16px Storopia";
        ctx.fillText("Click to continue", canvas.width / 2, 330);
    }

    // --- NORMAL WIN/FAIL SCREEN ---
    else {
        ctx.fillStyle = gameOver ? "#ff5555" : "#00ffcc";
        ctx.font = "bold 34px Storopia";
        ctx.fillText(gameOver ? "LEVEL FAILED!" : "LEVEL COMPLETE!", canvas.width / 2, 280);
        if (gameOver && gameOverReason) {
            ctx.fillStyle = "#FF0000"
			ctx.font = "20px Storopia";
            ctx.fillText(gameOverReason, canvas.width / 2, 350);
        }
		
        ctx.fillStyle = "#FFFFFF";
        ctx.font = "16px Storopia";
        ctx.fillText("Click to continue", canvas.width / 2, 420); // lol
        if (gameWin) {
    ctx.save();
    confetti.forEach(c => {
        ctx.globalAlpha = c.life;
        ctx.fillStyle = c.color;
        ctx.fillRect(c.x, c.y, 5, 5);
    });
    ctx.restore();
    }
        
   }

}

// ‚úÖ Keep these UI updates OUTSIDE the win-screen branches (and outside draw braces issues)
document.getElementById('scoreDisplay').innerText =
    `Score: ${fmt(score)}`;

document.getElementById('ammoDisplay').innerText =
    `Bubbles: ${fmt(ammo)}`;

const timerSpan = document.getElementById('campaignTimerDisplay');
const inner = document.getElementById('campaignTimerInner');
if (isCampaignMode) {
    const t = Math.ceil(campaignTimer);
    const minutes = Math.floor(t / 60);
    const seconds = t % 60;



if (isCampaignMode && timerSpan && inner) {
    const t = Math.ceil(campaignTimer);
    const minutes = Math.floor(t / 60);
    const seconds = t % 60;

    timerSpan.style.display = "inline";
    inner.innerText = `${minutes}:${seconds.toString().padStart(2, '0')}`;

    if (t <= 20) {
        inner.style.color = "#ff3333";
    } else if (t <= 60) {
        inner.style.color = "#ffcc00";
    } else {
        inner.style.color = "#66ff00";
    }
} else if (timerSpan) {
    timerSpan.style.display = "none";
}
}

// ---- Level Display Update ----
let levelText;
if (isCampaignMode) levelText = `${campaignLevel}/${CAMPAIGN_TOTAL_LEVELS}`;
else if (isPlaytesting && customLevelName && customAuthorName) levelText = `Custom (${customLevelName} by ${customAuthorName})`;
else if (mode === 'custom') levelText = "Custom Editor";
else levelText = level;

document.getElementById('levelDisplay').innerText = `Level: ${levelText}`;
document.getElementById('streakDisplay').innerText =
    `Streak: x${fmt(streakCount)} | Perfect streak: x${fmt(perfectStreak)}`;

}}
function gameLoop() { if (gameRunning) { update(); draw(); animationId = requestAnimationFrame(gameLoop); } }

function initializeAmmo(type, savedAmmo = null) {

        switch (type) {

            case "puzzleNew":
                ammo = Math.floor(Math.random() * 51) + 50;
                break;

            case "puzzleLoad":
                ammo = savedAmmo ?? 40;
                break;

            case "customPlaytest":
                ammo = parseInt(document.getElementById('customAmmoInput').value) || 40;
                break;

            case "customLoad":
                ammo = savedAmmo ?? 40;
                break;
        }

        updateAmmo();
    }
    function startPuzzleMode() {
        stats.puzzlePlays++;
        saveStats();
        setBrowserTitle("üß© SK's Bubble Shooter ‚Äî Puzzle Mode");
        isCampaignMode = false;   // ‚úÖ force campaign off
        campaignLevel = 1;
        campaignTimer = 0;
        lastTickSecond = null;
        hideCampaignTimer();
        startMode('puzzle');
    }
function hideCampaignTimer() {
    const timerSpan = document.getElementById('campaignTimerDisplay');
    if (timerSpan) {
        timerSpan.style.display = "none";
    }
}

function startMode(m, isLoad = false, isNextLevel = false) {
    mode = m; 
    // If manually starting puzzle mode from menu,
    // reset campaign ONLY if we're not already in campaign
    if (m === 'puzzle' && !isNextLevel && !isCampaignMode) {
        campaignLevel = 1;
        campaignTimer = 0;
        lastTickSecond = null;
    }
    gameRunning = true; gameOver = false; gameWin = false; isPaused = false; isCustomMode = false; isPlaytesting = false;
    lastClearWasPerfect = false;
    if (!isLoad) {

    if (!isNextLevel) {
        score = 0;
    }

    if (isCampaignMode) {
        level = campaignLevel;
    } else if (!isNextLevel) {
        level = 1;
    }

    if (!isNextLevel) {
    initializeAmmo("puzzleNew");
}


    if (!isLoad) {bubbles = [];} fallingBubbles = []; projectiles = []; particles = []; confetti = [];
    document.getElementById('mainMenu').style.display = 'none';
    document.getElementById('customUI').style.display = 'none';
    document.getElementById('gameUI').style.display = 'block';
	// force valid mouse position so aim line can render immediately
mouseX = canvas.width / 2;
mouseY = canvas.height - 200;

    document.getElementById('mobileControls').style.display = 'flex';
    document.getElementById('progressContainer').style.display = 'block';
    document.getElementById('streakContainer').style.display = 'block';
    document.getElementById('percentText').style.display = 'inline-block';
    canvas.style.display = 'block';
    
    // Generate new level layout
    if (!isLoad) {
    levelPattern = Math.floor(Math.random() * 50);
    for (let r = 0; r < Math.min(5 + Math.floor(level/2), 8); r++) {
        createRow(r);
    }
}
    if (isLoad) {
        // ammo will be set inside loadGame()
    }

    initialBubbleCount = bubbles.length; 
    updateProgressBar(); 
    updateAmmo();
    
    if (isNextLevel && mode === 'puzzle' && autosaveEnabled && !isCampaignMode) {
        saveGame(true);
    }


    if (animationId) cancelAnimationFrame(animationId);
    gameLoop();
    }
    refreshFavicon();
}
function enterCustomEditor() {
    stats.customPlays++;
    saveStats();
    setBrowserTitle("üõ†Ô∏è SK's Bubble Shooter ‚Äî Level Editor");
    mode = 'custom'; isCustomMode = true; gameRunning = true; gameOver = false; gameWin = false; isPlaytesting = false; isCampaignMode = false;
    hideCampaignTimer();
    document.getElementById('mainMenu').style.display = 'none';
    document.getElementById('customUI').style.display = 'block';
	// force valid mouse position so aim line can render immediately
mouseX = canvas.width / 2;
mouseY = canvas.height - 200;

    document.getElementById('gameUI').style.display = 'none';
    document.getElementById('mobileControls').style.display = 'flex';
    document.getElementById('progressContainer').style.display = 'none';
document.getElementById('percentText').style.display = 'none';
    canvas.style.display = 'block';
    updatePaletteUI();
    if (animationId) cancelAnimationFrame(animationId);
    gameLoop();
}

function hasAtLeastOneConnection(bubble) {
    const r = bubble.row;
    const c = bubble.col;

    const dirs = (r % 2 === 0)
        ? [[-1,-1],[-1,0],[0,-1],[0,1],[1,-1],[1,0]]
        : [[-1,0],[-1,1],[0,-1],[0,1],[1,0],[1,1]];

    return dirs.some(d =>
        bubbles.some(b =>
            b.row === r + d[0] &&
            b.col === c + d[1]
        )
    );
}
    function hasReachableColoredBubble() {
    const visited = new Set();
    const queue = [];

    // Start from all TOP ROW colored bubbles
    bubbles.forEach(b => {
        if (b.row === 0 && b.color) {
            queue.push(b);
            visited.add(`${b.row},${b.col}`);
        }
    });

    while (queue.length > 0) {
        const cur = queue.shift();

        // If we find ANY colored bubble, level is playable
        if (cur.color) return true;

        const dirs = (cur.row % 2 === 0)
            ? [[-1,-1],[-1,0],[0,-1],[0,1],[1,-1],[1,0]]
            : [[-1,0],[-1,1],[0,-1],[0,1],[1,0],[1,1]];

        dirs.forEach(([dr, dc]) => {
            const nr = cur.row + dr;
            const nc = cur.col + dc;
            const key = `${nr},${nc}`;

            if (visited.has(key)) return;

            const nb = bubbles.find(b => b.row === nr && b.col === nc);
            if (!nb) return;

            // ‚ùó BLOCK traversal through colourless bubbles
            if (!nb.color) return;

            visited.add(key);
            queue.push(nb);
        });
    }

    return false;
}
function startFromCustom() {
    if (bubbles.length === 0) {
        alert("Add some bubbles in the canvas first!");
        return;
    }

    if (bubbles.length < 3) {
        alert("Add at least 3 bubbles on to the canvas.");
        return;
    }

    // üö´ NEW CHECK ‚Äî colorless on top row
    const hasColorlessTopRow = bubbles.some(b => b.row === 0 && !b.color);
    if (hasColorlessTopRow) {
        alert("Don't put the colourless bubbles on the top row.");
        return;
    }

    // üö® existing floating-bubble check
    const hasFloating = bubbles.some(b => !hasAtLeastOneConnection(b));
    if (hasFloating) {
        alert("Connect one of the floating bubbles to another bubble.");
        return;
    }
        // üö´ Block inaccessible layouts (sealed by colourless bubbles)
if (!hasReachableColoredBubble()) {
    alert("This level has no reachable bubbles. Remove or reposition colourless bubbles.");
    return;
}
setBrowserTitle("‚ñ∂Ô∏è SK's Bubble Shooter ‚Äî Playtesting");
    customLevelSnapshot = JSON.parse(JSON.stringify(bubbles));
    isCustomMode = false;
    isPlaytesting = true;
    gameOver = false;
    gameWin = false;

    score = 0;
    streakCount = 1;
    streakTimer = 0;

    document.getElementById('customUI').style.display = 'none';
    document.getElementById('gameUI').style.display = 'block';
    document.getElementById('streakContainer').style.display = 'block';

    // ‚úÖ SHOW PROGRESS BAR
    document.getElementById('progressContainer').style.display = 'block';
    document.getElementById('percentText').style.display = 'inline-block';

    initializeAmmo("customPlaytest");

    initialBubbleCount = bubbles.length;
    updateProgressBar();
    updateAmmo();
}
    
function hasParentAbove(r, c) {

    if (r === 0) return true;

    const parents = (r % 2 === 0)
        ? [[r-1, c-1], [r-1, c]]
        : [[r-1, c], [r-1, c+1]];

    return parents.some(([pr, pc]) =>
        bubbles.some(b => b.row === pr && b.col === pc)
    );
}
function drawAimVisualizer() {

        if (!aimEnabled || isPaused || gameOver || gameWin || isCustomMode || projectiles.length > 0) return;

        if (
            mouseX < 0 ||
            mouseX > canvas.width ||
            mouseY < 0 ||
            mouseY > DEADLINE
        ) return;

        const startX = canvas.width / 2;
        const startY = canvas.height - 80;

        let simX = startX;
        let simY = startY;
        let dx = Math.cos(angle) * 12;
        let dy = Math.sin(angle) * 12;

        ctx.save();
        ctx.strokeStyle = currentBall;
        ctx.globalAlpha = 0.6;
        ctx.setLineDash([6, 6]);
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(simX, simY);

        for (let i = 0; i < 500; i++) {

            simX += dx;
            simY += dy;

            // wall bounce
            if (simX < RADIUS || simX > canvas.width - RADIUS) {
                dx *= -1;
            }

            // hit ceiling
            if (simY < RADIUS) {
                ctx.lineTo(simX, simY);
                break;
            }

            // üî• BUBBLE COLLISION CHECK (same as projectile)
            for (let b of bubbles) {
                if (Math.hypot(simX - b.x, simY - b.y) < RADIUS * 1.5) {
                    ctx.lineTo(simX, simY);
                    ctx.stroke();
                    ctx.restore();
                    return; // stop drawing here
                }
            }

            ctx.lineTo(simX, simY);
        }

        ctx.stroke();
        ctx.setLineDash([]);
        ctx.restore();
    }

function shouldPlaceBubble(r, c) {

    if (r === 0) return true;

    // First rule: must be attached to something above
    if (!hasParentAbove(r, c)) return false;

    const density = 0.55 + (Math.random() * 0.35);
    const centerBias = Math.abs(c - 5) < (Math.random() * 4 + 2);

    return Math.random() < density && centerBias;
}
    
function createRow(r) {
    const patternType = levelPattern; // decided per level

    for (let c = 0; c < (r % 2 === 0 ? 11 : 10); c++) {
        if (!shouldPlaceBubble(r, c)) continue;

        let color;

        // ‚úÖ Random colourless bubbles, but NEVER on top row
        if (r > 0 && Math.random() < COLORLESS_CHANCE) {
            color = null; // colourless / stone
        } else {
            switch (patternType) {
                case 0:  color = ALL_COLORS[(r + c) % ALL_COLORS.length]; break;
                case 1:  color = ALL_COLORS[c % ALL_COLORS.length]; break;
                case 2:  color = ALL_COLORS[r % ALL_COLORS.length]; break;
                case 3:  color = ALL_COLORS[Math.abs(c - 5) % ALL_COLORS.length]; break;
                case 4:  color = ALL_COLORS[Math.floor(Math.abs(c - 5) / 2) % ALL_COLORS.length]; break;
                case 5:  color = ALL_COLORS[(r * c) % ALL_COLORS.length]; break;
                case 6:  color = ALL_COLORS[(r * r + c) % ALL_COLORS.length]; break;
                case 7:  color = ALL_COLORS[(c * c + r) % ALL_COLORS.length]; break;
                case 8:  color = ALL_COLORS[(r + c * c) % ALL_COLORS.length]; break;
                case 9:  color = ALL_COLORS[(r * r + c * c) % ALL_COLORS.length]; break;

                case 10: color = ALL_COLORS[Math.floor(c / 2) % ALL_COLORS.length]; break;
                case 11: color = ALL_COLORS[Math.floor(r / 2) % ALL_COLORS.length]; break;
                case 12: color = ALL_COLORS[(Math.floor(c / 2) + r) % ALL_COLORS.length]; break;
                case 13: color = ALL_COLORS[(Math.floor(r / 2) + c) % ALL_COLORS.length]; break;
                case 14: color = ALL_COLORS[(r % 2 === 0 ? c : c + 3) % ALL_COLORS.length]; break;

                case 15: color = ALL_COLORS[(r % 3 + c % 3) % ALL_COLORS.length]; break;
                case 16: color = ALL_COLORS[(r % 4 + c % 2) % ALL_COLORS.length]; break;
                case 17: color = ALL_COLORS[(r % 5 + c % 3) % ALL_COLORS.length]; break;
                case 18: color = ALL_COLORS[(r % 2 ? c % 5 : c % 3) % ALL_COLORS.length]; break;
                case 19: color = ALL_COLORS[(r % 7 + c % 4) % ALL_COLORS.length]; break;

                case 20: color = ALL_COLORS[((Math.sin(r + c) * 10) | 0) % ALL_COLORS.length]; break;
                case 21: color = ALL_COLORS[((Math.cos(r * c) * 10) | 0) % ALL_COLORS.length]; break;
                case 22: color = ALL_COLORS[(Math.abs(r - c)) % ALL_COLORS.length]; break;
                case 23: color = ALL_COLORS[(Math.abs(r - 5) + Math.abs(c - 5)) % ALL_COLORS.length]; break;
                case 24: color = ALL_COLORS[(Math.max(r, c)) % ALL_COLORS.length]; break;

                case 25: color = ALL_COLORS[(r ^ c) % ALL_COLORS.length]; break;
                case 26: color = ALL_COLORS[((r << 1) + c) % ALL_COLORS.length]; break;
                case 27: color = ALL_COLORS[((c << 1) + r) % ALL_COLORS.length]; break;
                case 28: color = ALL_COLORS[((r & c) + c) % ALL_COLORS.length]; break;
                case 29: color = ALL_COLORS[((r | c) + r) % ALL_COLORS.length]; break;

                case 30: color = ALL_COLORS[Math.floor(Math.sqrt(r * c + 1)) % ALL_COLORS.length]; break;
                case 31: color = ALL_COLORS[Math.floor((r * c) / 2) % ALL_COLORS.length]; break;
                case 32: color = ALL_COLORS[Math.floor(((r + 1) * (c + 1)) / 3) % ALL_COLORS.length]; break;
                case 33: color = ALL_COLORS[Math.floor((r * r * c) / 7) % ALL_COLORS.length]; break;
                case 34: color = ALL_COLORS[Math.floor((c * c * r) / 7) % ALL_COLORS.length]; break;

                case 35: color = ALL_COLORS[(r % 2 === 0 ? r + c : r * c) % ALL_COLORS.length]; break;
                case 36: color = ALL_COLORS[(c % 2 === 0 ? r + c : r * c) % ALL_COLORS.length]; break;
                case 37: color = ALL_COLORS[((r + c) % 2 === 0 ? r : c) % ALL_COLORS.length]; break;
                case 38: color = ALL_COLORS[((r * c) % 2 === 0 ? r + c : r) % ALL_COLORS.length]; break;
                case 39: color = ALL_COLORS[((r + c) % 3 === 0 ? r * c : r + c) % ALL_COLORS.length]; break;

                case 40: color = ALL_COLORS[(r * 3 + c * 5) % ALL_COLORS.length]; break;
                case 41: color = ALL_COLORS[(r * 5 + c * 3) % ALL_COLORS.length]; break;
                case 42: color = ALL_COLORS[(r * 7 + c * 11) % ALL_COLORS.length]; break;
                case 43: color = ALL_COLORS[(r * 11 + c * 7) % ALL_COLORS.length]; break;
                case 44: color = ALL_COLORS[(r * 13 + c * 17) % ALL_COLORS.length]; break;

                case 45: color = ALL_COLORS[(Math.abs(5 - r) * Math.abs(5 - c)) % ALL_COLORS.length]; break;
                case 46: color = ALL_COLORS[(Math.abs(5 - r) + Math.abs(5 - c)) % ALL_COLORS.length]; break;
                case 47: color = ALL_COLORS[(Math.abs(5 - r) - Math.abs(5 - c) + 50) % ALL_COLORS.length]; break;
                case 48: color = ALL_COLORS[(r * r - c * c + 100) % ALL_COLORS.length]; break;
                case 49: color = ALL_COLORS[Math.floor(Math.random() * ALL_COLORS.length)]; break;

                default: color = ALL_COLORS[Math.floor(Math.random() * ALL_COLORS.length)]; break;
            }
        }

        let co = getGridCoords(r, c);

        // ‚úÖ Store color ONLY if it exists (keeps ‚Äúmissing color property‚Äù style)
        const bubble = { x: co.x, y: co.y, row: r, col: c };
        if (color) bubble.color = color;

        bubbles.push(bubble);
    }
}
function getGridCoords(r, c) {
    const off = (r % 2 === 0) ? 0 : RADIUS;
    return {
        x: RADIUS + (c * RADIUS * 2) + off,
        y: RADIUS + (r * ROW_HEIGHT)
    };
}

function findMatches(s) {
    // Colorless bubbles never match
    if (!s || !s.color) return [s];

    let m = [s];
    let seen = new Set([`${s.row},${s.col}`]);
    let q = [s];

    while (q.length > 0) {
        let cur = q.shift();
        let ds = (cur.row % 2 === 0)
            ? [[-1,-1],[-1,0],[0,-1],[0,1],[1,-1],[1,0]]
            : [[-1,0],[-1,1],[0,-1],[0,1],[1,0],[1,1]];

        ds.forEach(d => {
            let nb = bubbles.find(o => o.row === cur.row + d[0] && o.col === cur.col + d[1]);
            if (!nb) return;
            if (!nb.color) return;                 // ignore colorless
            const key = `${nb.row},${nb.col}`;
            if (seen.has(key)) return;
            if (nb.color !== s.color) return;

            seen.add(key);
            m.push(nb);
            q.push(nb);
        });
    }
    return m;
}
function dropFloatingBubbles() {
    const connected = new Set();
    const queue = bubbles.filter(b => b.row === 0);

    queue.forEach(b => connected.add(`${b.row},${b.col}`));

    let i = 0;
    while (i < queue.length) {
        const curr = queue[i++];
        const dirs = (curr.row % 2 === 0)
            ? [[-1,-1],[-1,0],[0,-1],[0,1],[1,-1],[1,0]]
            : [[-1,0],[-1,1],[0,-1],[0,1],[1,0],[1,1]];

        dirs.forEach(([dr, dc]) => {
            const nb = bubbles.find(b => b.row === curr.row + dr && b.col === curr.col + dc);
            if (!nb) return;

            const key = `${nb.row},${nb.col}`;
            if (connected.has(key)) return;

            connected.add(key);
            queue.push(nb);
        });
    }

    const remaining = [];
    let droppedCount = 0;

    bubbles.forEach(b => {
        if (connected.has(`${b.row},${b.col}`)) {
            remaining.push(b);
        } else {
            // ‚úÖ send to falling animation
            fallingBubbles.push({
                x: b.x,
                y: b.y,
                color: b.color
            });
            droppedCount++;
        }
    });

    if (droppedCount > 0) {
        sounds.play('fall');
        stats.bubblesDropped += droppedCount;
        saveStats();
    }

    bubbles = remaining;
}
	
function updateAmmo(rollNext = false) {
    // Pool = colors that exist on board (ignore colorless)
    const pool = bubbles.length > 0
        ? Array.from(new Set(bubbles.map(b => b.color).filter(c => c)))
        : ALL_COLORS;
if (isLoadingSave) {
        refreshFavicon();
        return;
    }
    // If current is missing/invalid, fix it
    if (!currentBall || !pool.includes(currentBall)) {
        currentBall = pool[Math.floor(Math.random() * pool.length)];
    }

    // Only roll next when requested OR if next is invalid
    if (rollNext || !nextBall || !pool.includes(nextBall)) {
        nextBall = pool[Math.floor(Math.random() * pool.length)];
    }

    refreshFavicon();
}

function swapBubbles() { [currentBall, nextBall] = [nextBall, currentBall]; sounds.play('swap'); refreshFavicon(); stats.bubblesSwapped++; saveStats();}
function triggerConfetti() { for(let i=0; i<50; i++) confetti.push({ x: 220, y: 300, vx: (Math.random()-0.5)*10, vy: (Math.random()-0.5)*10, color: ALL_COLORS[Math.floor(Math.random()*6)], life: 1.0 }); }
function updatePaletteUI() {
    const p = document.getElementById('colorPalette');
    p.innerHTML = '';

    // show "√ò" first, then normal colors
    const palette = [null, ...ALL_COLORS];

    palette.forEach(c => {
        const b = document.createElement('div');
        b.className = 'palette-btn' + (c === selectedColor ? ' active' : '');

        if (c === null) {
            b.style.background = "transparent";
            b.style.border = "2px dashed white";
            b.style.display = "inline-flex";
            b.style.alignItems = "center";
            b.style.justifyContent = "center";
            b.style.color = "white";
            b.style.fontWeight = "bold";
            b.innerText = "√ò";
            b.title = "Colorless bubble";
        } else {
            b.style.backgroundColor = c;
            b.title = c;
        }

        b.onclick = () => {
            selectedColor = c;     // ‚úÖ can be null
            updatePaletteUI();
        };

        p.appendChild(b);         // ‚úÖ IMPORTANT
    });
}
    function saveGame(isAuto = false, forceSave = false) {

    if (isCampaignMode) {
        alert("Cannot create a save file in campaign mode.");
        return;
    }

    if (isPlaytesting) {
        alert("Cannot create a save file in playtest mode.");
        return;
    }

    const ts = getSaveTimestamp();

    const saveData = {
    _metadata: {
        timestamp: ts.readable,
        epoch: ts.epoch,
        gameType:
            (mode === 'custom' || isPlaytesting) ? "CUSTOM" :
            isCampaignMode ? "CAMPAIGN" :
            "PUZZLE",
        saveMethod: isAuto ? "AUTO" : "MANUAL"
    },

    mode,
    level: (mode === 'custom' || isPlaytesting) ? "CUSTOM LEVEL" : level,
    levelName: (mode === 'custom' || isPlaytesting) ? customLevelName : null,
    authorName: (mode === 'custom' || isPlaytesting) ? customAuthorName : null,

    // üìä CORE STATS (ordered)
    score,
	perfect_streak: perfectStreak,
    ammo: (mode === 'custom' || isPlaytesting)
        ? parseInt(document.getElementById('customAmmoInput')?.value) || ammo
        : ammo,
    progress: (mode === 'custom' && !isPlaytesting)
        ? "0.0%"
        : getProgress(),

    // ü´ß GAME STATE
    bubbles,

    currentBubble: currentBall ?? null,
    nextBubble: nextBall ?? null
};


    const blob = new Blob(
        [JSON.stringify(saveData, null, 2)],
        { type: 'text/plain' }
    );

    const a = document.createElement('a');

    if (mode === 'custom' || isPlaytesting) {
        const safeLevel = (customLevelName || "Untitled").replace(/[\\\/:*?"<>|]/g, "_");
        const safeAuthor = (customAuthorName || "Unknown").replace(/[\\\/:*?"<>|]/g, "_");
        a.download = `customModeLevel_${safeLevel}_${safeAuthor}.bubblesav`;
    } else {
        const prefix = isAuto ? "(AUTOSAVE) " : "";
        a.download = `${prefix}puzzleModeLevel_${level}.bubblesav`;
    }

    a.href = URL.createObjectURL(blob);
    a.click();
}
    function getSaveTimestamp() {
    const d = new Date();

    const pad = n => n.toString().padStart(2, '0');

    // ----- DAY & MONTH NAMES -----
    const days = [
        "Sunday", "Monday", "Tuesday", "Wednesday",
        "Thursday", "Friday", "Saturday"
    ];

    const months = [
        "January", "February", "March", "April",
        "May", "June", "July", "August",
        "September", "October", "November", "December"
    ];

    const dayName = days[d.getDay()];
    const day = d.getDate();
    const monthName = months[d.getMonth()];
    const year = d.getFullYear();

    // ----- ORDINAL SUFFIX -----
    let suffix = "th";
    if (day % 10 === 1 && day !== 11) suffix = "st";
    else if (day % 10 === 2 && day !== 12) suffix = "nd";
    else if (day % 10 === 3 && day !== 13) suffix = "rd";

    // ----- 12-HOUR TIME -----
    let h = d.getHours();
    const ampm = h >= 12 ? "PM" : "AM";
    h = h % 12;
    if (h === 0) h = 12;

    const m = pad(d.getMinutes());
    const s = pad(d.getSeconds());

    // ----- UTC OFFSET (+HHMM / -HHMM) -----
    const offsetMinutes = -d.getTimezoneOffset();
    const sign = offsetMinutes >= 0 ? "+" : "-";

    const abs = Math.abs(offsetMinutes);
    const oh = pad(Math.floor(abs / 60));
    const om = pad(abs % 60);

    const offset = `${sign}${oh}${om}`;

    return {
        readable:
            `${dayName}, ${day}${suffix} ${monthName} ${year} ` +
            `${h}:${m}:${s} ${ampm} ${offset}`,
        epoch: Math.floor(d.getTime() / 1000)
    };
}
    function openCustomSavePopup() {
    
        if (bubbles.length === 0) {
        alert("Add some bubbles in the canvas first!");
        return;
    }

    if (bubbles.length < 3) {
        alert("Add at least 3 bubbles on to the canvas.");
        return;
    }

    // üö´ NEW CHECK ‚Äî colorless on top row
    const hasColorlessTopRow = bubbles.some(b => b.row === 0 && !b.color);
    if (hasColorlessTopRow) {
        alert("Don't put the colourless bubbles on the top row.");
        return;
    }

    // üö® existing floating-bubble check
    const hasFloating = bubbles.some(b => !hasAtLeastOneConnection(b));
    if (hasFloating) {
        alert("Connect one of the floating bubbles to another bubble.");
        return;
    }
        // üö´ Block inaccessible layouts (sealed by colourless bubbles)
if (!hasReachableColoredBubble()) {
    alert("This level has no reachable bubbles. Remove or reposition colourless bubbles.");
    return;
}
        if (!isCustomMode) {
        saveGame(); // normal save outside editor
        return;
    }

    document.getElementById('customSavePopup').style.display = 'flex';

    // optional: prefill last values
    document.getElementById('levelNameInput').value = customLevelName || "";
    document.getElementById('authorNameInput').value = customAuthorName || "";
}
function confirmCustomSave() {
    customLevelName = (document.getElementById('levelNameInput')?.value || "").trim();
    customAuthorName = (document.getElementById('authorNameInput')?.value || "").trim();

    if (!customLevelName || !customAuthorName) {
        alert("Enter both Level Name and Author Name.");
        return;
    }

    const popup = document.getElementById('customSavePopup');
    if (popup) popup.style.display = 'none';

    // IMPORTANT: forceSave=true so it doesn't reopen the popup
    saveGame(false, true);
}
function handleLoadClick() {
    
    if (isCampaignMode) {
    alert("Cannot load a save file in campaign mode.");
    return;
}


    if (isPlaytesting) {
            alert("Cannot load a save file in playtest mode.");
            return;
        }
        document.getElementById('fileInput').click();
    }

function loadGame(e) {
    const file = e.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    isLoadingSave = true;

    reader.onload = (ev) => {
        const s = JSON.parse(ev.target.result);

        // -----------------------------
        // Restore basic metadata
        // -----------------------------
        customLevelName = s.levelName || "";
        customAuthorName = s.authorName || "";

        // -----------------------------
        // CUSTOM LEVEL LOAD
        // -----------------------------
        if (s.level === "CUSTOM LEVEL") {

            enterCustomEditor();

            bubbles = [];
            s.bubbles.forEach(b => {
                const co = getGridCoords(b.row, b.col);
                const nb = {
                    x: co.x,
                    y: co.y,
                    row: b.row,
                    col: b.col
                };
                if (b.color) nb.color = b.color;
                bubbles.push(nb);
            });

            ammo = s.ammo ?? 40;
            document.getElementById('customAmmoInput').value = ammo;

            // progress is irrelevant in editor
            loadedProgressOverride = null;

            isLoadingSave = false;
            updateAmmo(false);
            refreshFavicon();
            return;
        }

        // -----------------------------
        // PUZZLE MODE LOAD
        // -----------------------------

        // Restore level & score FIRST
        level = s.level ?? 1;
        score = s.score ?? 0;

        // Capture saved progress AS-IS (string like "12.1%")
        if (typeof s.progress === "string") {
            loadedProgressOverride = s.progress;
        } else {
            loadedProgressOverride = null;
        }

        // Start game WITHOUT resetting
        startMode('puzzle', true);

        // Rebuild bubbles AFTER startMode
        bubbles = [];
        s.bubbles.forEach(b => {
            const co = getGridCoords(b.row, b.col);
            const nb = {
                x: co.x,
                y: co.y,
                row: b.row,
                col: b.col
            };
            if (b.color) nb.color = b.color;
            bubbles.push(nb);
        });

        // Restore shooter state
        ammo = s.ammo ?? ammo;
		perfectStreak = s.perfect_streak ?? 0;
        currentBall = s.currentBubble ?? currentBall;
        nextBall = s.nextBubble ?? nextBall;

        // IMPORTANT:
        // Do NOT recompute initialBubbleCount here
        // Do NOT touch progress math

        isLoadingSave = false;

        // Force UI refresh
        updateProgressBar();
        updateAmmo(false);
        refreshFavicon();
    };

    reader.readAsText(file);
}
function closeCustomSavePopup() {
    const popup = document.getElementById('customSavePopup');
    if (popup) popup.style.display = 'none';
}
    const SFX_TYPES = [
    'shoot',
    'pop',
    'bounce',
    'place',
    'swap',
    'fall',
    'win',
    'fail',
   'panic',
    'tick'
];

function openSfxMenu() {
    const menu = document.getElementById('sfxMenu');
    const list = document.getElementById('sfxList');
    list.innerHTML = '';

    SFX_TYPES.forEach(type => {
        const row = document.createElement('div');
        row.style.margin = '8px 0';
        row.style.display = 'flex';
        row.style.justifyContent = 'space-between';
        row.style.alignItems = 'center';

        const label = document.createElement('span');
        label.innerText = type.toUpperCase();
        label.style.flex = '1';

        const btn = document.createElement('button');
        btn.innerText = '‚ñ∂ PLAY';
        btn.style.background = '#00ffcc';
        btn.style.color = '#000';
        btn.style.border = 'none';
        btn.style.padding = '5px 10px';
        btn.style.borderRadius = '5px';
        btn.onclick = () => sounds.play(type);

        row.appendChild(label);
        row.appendChild(btn);
        list.appendChild(row);
    });

    menu.style.display = 'flex';
}

function closeSfxMenu() {
    document.getElementById('sfxMenu').style.display = 'none';
}
    function resetProgressBar() {
    loadedProgressOverride = null;
    initialBubbleCount = 0;

    document.getElementById('progressBar').style.width = "0%";
    document.getElementById('percentText').innerText = "0.0%";

    document.getElementById('progressContainer').style.display = "none";
    document.getElementById('percentText').style.display = "none";
}
function clearEditor() { if(confirm("Clear level?")) bubbles = []; }
function exitToMenu() { setBrowserTitle("‚≠ê SK's Bubble Shooter"); gameRunning = false; document.getElementById('mainMenu').style.display = 'block';  document.getElementById('gameUI').style.display = 'none'; document.getElementById('customUI').style.display = 'none'; document.getElementById('mobileControls').style.display = 'none'; canvas.style.display = 'none'; perfectStreak = 0; updateStatsBoard(); updateFavicon(); resetProgressBar(); addSfxButtonToMenu();}
updateStatsBoard();
	updateFavicon();
addSfxButtonToMenu();

</script>
    <div id="customSavePopup" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,0.85);z-index:9999;align-items:center;justify-content:center;">
  <div style="background:#222;padding:25px;border-radius:12px;border:2px solid #00ffcc;text-align:center;">
    <h2 style="color:#00ffcc;">Save Custom Level</h2>

    <input id="levelNameInput" placeholder="Level Name"
      style="display:block;margin:10px auto;padding:8px;width:220px;background:#000;color:#00ffcc;border:1px solid #333;">

    <input id="authorNameInput" placeholder="Author Name"
      style="display:block;margin:10px auto;padding:8px;width:220px;background:#000;color:#00ffcc;border:1px solid #333;">

    <button onclick="confirmCustomSave()" style="margin-top:10px;background:#00ffcc;color:#000;font-weight:bold;">
      CONFIRM SAVE
    </button>
  </div>
        <button onclick="closeCustomSavePopup()" 
    style="background:#ff5555;color:#fff;font-weight:bold; padding:8px 18px;">
    CANCEL
  </button>
</div>
</div>
    <div id="sfxMenu" style="
display:none;
position:fixed;
inset:0;
background:rgba(0,0,0,0.9);
z-index:9999;
align-items:center;
justify-content:center;
">
  <div style="
    background:#222;
    padding:25px;
    border-radius:12px;
    border:2px solid #00e5ff;
    width:320px;
    text-align:center;
    color:white;
  ">
    <h2 style="color:#00e5ff;">SFX Tester</h2>

    <div id="sfxList" style="margin-top:15px;"></div>

    <button onclick="closeSfxMenu()" style="
      margin-top:20px;
      background:#ff5555;
      padding:8px 20px;
      border:none;
      border-radius:6px;
      color:white;
      font-weight:bold;
    ">CLOSE</button>
  </div>
</div>
</body>
</html>
<!--Note: This game was made with a help of ChatGPT and Gemini. (Don't judge me.) lol-->















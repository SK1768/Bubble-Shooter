<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>‚≠ê SK's Bubble Shooter</title>
    <link id="dynamicFavicon" rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>‚≠ê</text></svg>">
    <style>

        @font-face {
            font-family: 'Storopia';
            src: url('./fonts/Storopia.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
        }
@keyframes tickPulse {
    0% {
        text-shadow:
            0 0 0 rgba(255, 80, 80, 0);
        transform: scale(1);
    }

    40% {
        text-shadow:
            0 0 12px rgba(255, 80, 80, 0.8),
            0 0 24px rgba(255, 80, 80, 0.6),
            0 0 40px rgba(255, 80, 80, 0.4);
        transform: scale(1.15);
    }

    100% {
        text-shadow:
            0 0 0 rgba(255, 80, 80, 0);
        transform: scale(1);
    }
}


.tick-pulse {
    animation: tickPulse 0.25s ease-out;
}



.tick-pulse {
    animation: tickPulse 0.25s ease-out;
}
        /* Apply font globally */
        body, button, input, span, div, p, h1, h2, #debugConsole, #debugInput {
            font-family: 'Storopia', sans-serif;
        }

        body {
            background: #000000;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

            .game-container {
                position: relative;
                width: 100%;
                display: flex;
                justify-content: center;
            }

            canvas {
                background: #000000;
                border: 4px solid #333;
                box-shadow: 0 0 20px rgba(0,0,0,0.5);
                display: none;
                cursor: cell;
            }
.menuDescription {
    margin-top: 14px;
    font-family: Storopia;
    font-size: 14px;
    color: #cccccc;
    text-align: center;
    min-height: 32px; /* prevents layout jump */
}

            .menu, .ui {
                margin: 10px;
                text-align: center;
                width: 100%;
                max-width: 600px;
            }

            button {
                padding: 10px 20px;
                cursor: pointer;
                background: #444;
                color: white;
                border: none;
                border-radius: 5px;
                margin: 5px;
                transition: 0.2s;
                font-weight: bold;
            }

                button:hover {
                    background: #00ffcc;
                    color: #000;
                }

            .back-btn {
                background: #ff5555;
            }

            #fileInput {
                display: none;
            }

            #mobileControls {
                position: absolute;
                top: 140px; /* adjust if you want */
                left: 50%;
                transform: translateX(240px); /* ‚úÖ puts it to the RIGHT of centered canvas */
                display: none;
                flex-direction: column;
                gap: 10px;
            }

            .mobile-btn {
                width: 60px;
                height: 60px;
                border-radius: 50%;
                background: #333;
                border: 2px solid #555;
                font-size: 0.8em;
                padding: 5px;
                color: white;
            }

                .mobile-btn:active {
                    background: #00ffcc;
                    color: #000;
                }
        #musicPanel {
    position: absolute;
    top: 140px;
    left: 50%;
    transform: translateX(340px);
    width: 220px;
    background: #111;
    border: 2px solid #00ffcc;
    border-radius: 10px;
    padding: 10px;
    color: #00ffcc;
    font-family: Storopia;
}

.music-buttons {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
    justify-content: center;
    margin-bottom: 8px;
}

.music-buttons button {
    width: 36px;
    height: 36px;
    border-radius: 50%;
    background: #333;
    border: none;
    cursor: pointer;
}

#musicPanel input[type=range] {
    width: 100%;
}

#playlist div {
    font-size: 13px;
    margin-top: 4px;
    cursor: pointer;
}

        #debugConsole {
            display: none;
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            max-width: 400px;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #00ffcc;
            padding: 10px;
            z-index: 1000;
            border-radius: 5px;
            font-family: 'Storopia', monospace;
        }

        #debugInput {
            width: 100%;
            background: #000;
            color: #00ffcc;
            border: 1px solid #333;
            padding: 5px;
            font-family: 'Storopia', monospace;
            outline: none;
        }
            /* Centered Progress & Streak Bars */
            .bars-container {
                display: flex;
                flex-direction: column;
                align-items: center;
                width: 100%;
                margin-bottom: 10px;
                position: relative;
            }

            .progress-wrapper {
                display: flex;
                align-items: center;
                justify-content: center;
                width: 100%;
                position: relative;
            }

            #progressContainer {
                width: 400px;
                height: 12px;
                background: #333;
                border-radius: 6px;
                display: none;
                overflow: hidden;
                border: 1px solid #444;
            }
            #bubbleHexOverlay {
            position: fixed;
            pointer-events: none;
            z-index: 9999;

            font-family: Storopia, sans-serif;
            font-size: 14px;
            padding: 6px 8px;

            background: rgba(0,0,0,0.75);
            border-radius: 4px;

            display: none;
            }
canvas {
    background: #000;
    border: 4px solid #333;

    box-shadow:
        0 0 var(--glow-size, 0px)
        var(--glow-color, rgba(0,0,0,0));

    transition: box-shadow 0.2s ease;
}


            #progressBar {
                height: 100%;
                width: 0%;
                background: linear-gradient(90deg, #00ffcc, #00e5ff);
                transition: width 0.3s ease;
            }

            #percentText {
                font-weight: bold;
                color: #00ffcc;
                position: absolute;
                left: calc(50% + 210px);
                display: none;
                white-space: nowrap;
            }

            #streakContainer {
                width: 300px;
                height: 6px;
                background: #222;
                border-radius: 3px;
                display: none;
                overflow: hidden;
                border: 1px solid #333;
                margin-top: 5px;
            }

            #streakBar {
                height: 100%;
                width: 0%;
                background: #00e5ff;
                box-shadow: 0 0 8px #00e5ff;
                transition: width 0.1s linear;
            }

            #customUI {
                display: none;
                text-align: center;
                margin: 10px;
                background: #222;
                padding: 15px;
                border-radius: 10px;
                border: 1px solid #444;
            }

            .palette-btn {
                width: 30px;
                height: 30px;
                border-radius: 50%;
                cursor: pointer;
                display: inline-block;
                margin: 5px;
                border: 2px solid #333;
            }

                .palette-btn.active {
                    border: 3px solid white;
                    box-shadow: 0 0 10px white;
                    transform: scale(1.1);
                }

            .ammo-input {
                background: #000;
                color: #00ffcc;
                border: 1px solid #444;
                padding: 5px;
                width: 50px;
                text-align: center;
                border-radius: 4px;
                font-weight: bold;
            }

            #soundToggle {
                background: #555;
            }

            #autosaveToggle {
                background: #444;
            }
            #campaignTimerDisplay {
    position: absolute;
    top: 5000%;
    left: 100.5%;
    transform: translate(-50%, -50%);

    color: #66ff00;
    font-weight: bold;
    font-family: Storopia;
    font-size: 50px;

    pointer-events: none; /* clicks go through */
    display: none;
}
#livesInner {
    display: inline-block;
    transform-origin: center center;
    will-change: transform;
}

    </style>
</head>
<body oncontextmenu="return false;">

    <div class="menu" id="mainMenu">
        <h1>SK's Bubble Shooter</h1>
        <p>Made by SK1768 :)</p>
        <button onclick="startPuzzleMode()" style="font-size: 1.5em; background: #00ffcc; color: #000;" onmouseenter="setMenuDesc('Puzzle Mode: Clear all bubbles using limited ammo.')" onmouseleave="clearMenuDesc()">üß© PUZZLE MODE</button>
        <br>
        <button onclick="enterCustomEditor()" style="background: #a155ff;"onmouseenter="setMenuDesc('Custom Mode: Create and test your own bubble layouts.')" onmouseleave="clearMenuDesc()">üõ†Ô∏è CUSTOM MODE</button>
        <br>
        <button onclick="startCampaign()" style="background:#ff9500; font-weight:bold;"onmouseenter="setMenuDesc('Campaign Mode: Beat 20 levels before the timer runs out.')" onmouseleave="clearMenuDesc()">
            üèÜ CAMPAIGN MODE
        </button>
        <br>
        <button id="autosaveToggle" onclick="toggleAutosave()" onmouseenter="setMenuDesc('Autosave: Creates a save file every time you complete a level in Puzzle Mode.')" onmouseleave="clearMenuDesc()">üíæ Autosave: OFF</button>
        <button id="soundToggle" onclick="toggleSound()" onmouseenter="setMenuDesc('Sound: Toggles the in game\'s sound. Note: SFX Tester will not play any sound effects when the sound is off.')" onmouseleave="clearMenuDesc()">üîä Sound: ON</button>
        <br>
        
        <button
    onclick="resetStats()"
    style="margin-top:10px; background:#ff5555; color:#000; font-weight:bold;"
    onmouseenter="setMenuDesc('Resets ALL saved stats. This cannot be undone.')"
    onmouseleave="clearMenuDesc()"
>
    üóëÔ∏è RESET STATS
</button>
		<div id="menuDescription" class="menuDescription">
</div>
		<h3 style="margin-top:0;text-align:center;">üìä Player Stats</h3>
		<div id="statsBoard" style="
    margin:15px auto;
    padding:15px;
    background:#111;
    border:2px solid #00ffcc;
    border-radius:10px;
    color:#00ffcc;
    font-size:14px;
    max-width:360px;
    box-shadow:0 0 20px rgba(0,255,204,0.15);
">
    <div id="statsContent"></div>
</div>
		<div id="menuDescription" class="menuDescription">
</div>
    </div>

<br>
    <div id="customUI">
        <span style="color:#a155ff; font-weight:bold; margin: 100 100px;">üõ†Ô∏è CUSTOM MODE</span>
        <div style="margin-bottom: 10px;">
            <button class="back-btn" onclick="exitToMenu()">‚Üê MENU</button>
            <button onclick="openCustomSavePopup()" style="background:#4CAF50;">SAVE FILE</button>
            <button onclick="document.getElementById('fileInput').click()" style="background:#2196F3;">LOAD FILE</button>
            <button onclick="clearEditor()" style="background:#cc3300;">CLEAR ALL</button>
        </div>
        <div style="background: #333; padding: 10px; border-radius: 5px; display: inline-block;">
            <label>Set Ammo: </label>
            <input type="number" id="customAmmoInput" class="ammo-input" value="40" min="1">
            <button onclick="startFromCustom()" style="background:#00ffcc; color:#000;">PLAY TEST</button>
        </div>
        <div id="colorPalette" style="margin-top: 10px;"></div>
    </div>

  
    <div id="debugConsole">
        <input type="text" id="debugInput" placeholder="Enter a command...">
    </div>

    <div id="gameUI" class="ui" style="display:none">
        <div class="bars-container">
            <div class="progress-wrapper">
                <div id="progressContainer"><div id="progressBar"></div>
            <span id="campaignTimerDisplay">
    <span id="campaignTimerInner">05:00</span>
</span>
<span id="livesDisplay"
      style="
        position: absolute;
        top: -34px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 20px;
        font-weight: bold;
        pointer-events: none;
        display: none;
        z-index: 5;
        min-width: 60px;
        text-align: center;
      ">
    <span id="livesInner">‚ù§Ô∏è5</span>
</span>

            </div>
                <span id="percentText">0.0%</span>
            </div>
            <div id="streakContainer"><div id="streakBar"></div></div>
        </div>
        <button class="back-btn" onclick="exitToMenu()">‚Üê MENU</button> |
        <button onclick="saveGame()" style="background:#4CAF50;">SAVE</button>
        <button id="loadBtn" onclick="handleLoadClick()" style="background:#2196F3;">LOAD</button>
|
        <button id="pauseBtn" onclick="togglePause()" style="background:#ffcc00; color:#000;">PAUSE</button><br><br>
        <span id="levelDisplay">Level: 1</span> |
        <span id="scoreDisplay">Score: 0</span> |
        <span id="streakDisplay" style="color:#00e5ff; font-weight:bold;">Streak: x1</span>

    </div>

    <div class="game-container">
        <canvas id="gameCanvas" width="440" height="640"></canvas>
		<div id="bubbleHexOverlay"></div>
        <div id="mobileControls">
    <button class="mobile-btn" onclick="swapBubbles()">SWAP</button>
    <button class="mobile-btn" id="debugBtn" onclick="openDebug()">DEBUG</button>

    <!-- NEW: moved here -->
    <button class="mobile-btn" id="colorblindToggle" onclick="toggleColorblind()">üëÅÔ∏è</button>
    <button class="mobile-btn" id="aimToggle" onclick="toggleAim()">üéØ</button>
</div>
        <div id="musicPanel">
			<h3 style="margin-top:0;text-align:center;">üéµ Music Player</h3>
    <div id="trackState">Stopped</div>
    <div id="trackTime">0:00 / 0:00</div>
	<div id="soundtouchWarning"
     style="
        display:none;
        margin-bottom:6px;
        color:#ff4444;
        font-weight:bold;
        text-align:center;
        font-size:13px;
     ">
    ‚ö†Ô∏è SoundTouch.js is missing!<br>
    The music player will not work without it.
</div>
    <input type="file" id="musicInput" accept=".mp3,.ogg,.wav">

    <div class="music-buttons">
    <button id="playBtn">‚ñ∂Ô∏è</button>
    <button id="stopBtn">‚èπÔ∏è</button>
    <button id="repeatBtn">üîÅ OFF</button><br>
		<button id="seekBackBtn">‚è™ 5s</button>
		<button id="seekFwdBtn">‚è© 5s</button>
</div>
    <label>
  Seek:
  <span id="seekPercent">0.0%</span>
</label>
<input type="range" id="seekSlider" min="0" max="100" value="0">

    <label>Transpose: <span id="transposeValue">0</span></label>
<input type="range" id="pitchSlider" min="-36" max="36" value="0">

<label>Tempo: <span id="tempoValue">100%</span></label>
<input type="range" id="tempoSlider" min="5" max="500" value="100">
			<div class="music-step-buttons">
 <button id="transposeUpBtn">‚ûï Transpose</button>
 <button id="transposeDownBtn">‚ûñ Transpose</button>
 <button id="tempoUpBtn">‚ûï Tempo</button>
<button id="tempoDownBtn">‚ûñ Tempo</button>
</div>

</div>
		
    </div>

    <input type="file" id="fileInput" accept=".bubblesav" onchange="loadGame(event)">

<script type="module">
import { SoundTouch, SimpleFilter } from "./soundtouch.js";

window.SoundTouch = SoundTouch;
window.SimpleFilter = SimpleFilter;

console.log("SoundTouch:", typeof window.SoundTouch);
console.log("SimpleFilter:", typeof window.SimpleFilter);
</script>

<script>
    // ======================
// PLAYER STATS SYSTEM
// ======================

const DEFAULT_STATS = {
    levelsCompleted: 0,
	levelsCompletedPerfectly: 0,
    levelsFailed: 0,
    campaignWins: 0,

    bubblesShot: 0,
    bubblesSwapped: 0,
	bubblesPopped: 0,
	bubblesDropped: 0,

    totalStreak: 0,
    perfectStreak: 0,

    puzzlePlays: 0,
    campaignPlays: 0,
    customPlays: 0,
    livesGained: 0,
    livesLost: 0,
    
    livesGained: 0,
    livesLost: 0,

    debugCommandsUsed: 0,
	
    highScore: 0,
};
    
// ======================
// SOUNDTouch-ONLY MUSIC PLAYER (no <audio> element)
// ======================

// IMPORTANT: keep separate from your SFX `audioCtx`
const MusicAudioCtx = window.AudioContext || window.webkitAudioContext;
const musicCtx = new MusicAudioCtx();
let musicBuffer = null;          // decoded AudioBuffer
let soundTouch = null;           // SoundTouch instance
let filter = null;               // SimpleFilter
let processor = null;            // ScriptProcessor
let isMusicPlaying = false;
let currentTrackName = "";
let rafId = null;
let repeatEnabled = false;
// We track playback position in INPUT samples (source samples)
let positionSamples = 0;
let playStartCtxTime = 0;        // musicCtx.currentTime when we started outputting
let lastUiUpdate = 0;

// UI elements
const musicInput  = document.getElementById("musicInput");
const playBtn     = document.getElementById("playBtn");
const stopBtn     = document.getElementById("stopBtn");
const seekSlider  = document.getElementById("seekSlider");
const pitchSlider = document.getElementById("pitchSlider");
const tempoSlider = document.getElementById("tempoSlider");
const trackState  = document.getElementById("trackState");
const trackTime   = document.getElementById("trackTime");
const transposeValue = document.getElementById("transposeValue");
const tempoValue = document.getElementById("tempoValue");
	const repeatBtn = document.getElementById("repeatBtn");
	const seekBackBtn = document.getElementById("seekBackBtn");
const seekFwdBtn  = document.getElementById("seekFwdBtn");
	const transposeDownBtn = document.getElementById("transposeDownBtn");
const transposeUpBtn   = document.getElementById("transposeUpBtn");
const tempoDownBtn     = document.getElementById("tempoDownBtn");
const tempoUpBtn       = document.getElementById("tempoUpBtn");
	const seekPercent = document.getElementById("seekPercent");

function stepSlider(sliderEl, delta) {
  const min = Number(sliderEl.min);
  const max = Number(sliderEl.max);
  const cur = Number(sliderEl.value);
  const next = Math.max(min, Math.min(max, cur + delta));
  sliderEl.value = String(next);

  // ‚úÖ trigger your existing oninput handlers
  sliderEl.dispatchEvent(new Event("input", { bubbles: true }));
}

transposeDownBtn.onclick = () => stepSlider(pitchSlider, -1);
transposeUpBtn.onclick   = () => stepSlider(pitchSlider,  1);
tempoDownBtn.onclick     = () => stepSlider(tempoSlider, -1);
tempoUpBtn.onclick       = () => stepSlider(tempoSlider,  1);

seekBackBtn.onclick = () => seekBySeconds(-5);
seekFwdBtn.onclick  = () => seekBySeconds(5);
	function seekBySeconds(deltaSec) {
    if (!musicBuffer) return;

    const duration = musicBuffer.duration;

    // current position in seconds
    let currentSec = positionSamples / musicBuffer.sampleRate;

    // move by delta
    currentSec += deltaSec;

    // clamp
    currentSec = Math.max(0, Math.min(duration, currentSec));

    // convert back to samples
    positionSamples = Math.floor(
        currentSec * musicBuffer.sampleRate
    );

    // update UI immediately
    setTimeText(currentSec, duration);
    seekSlider.value = (currentSec / duration) * 100;

    // if playing, rebuild graph at new position
    if (isMusicPlaying) {
        buildGraphFromPosition();
    }
}

repeatBtn.onclick = () => {
    repeatEnabled = !repeatEnabled;
    repeatBtn.textContent = repeatEnabled ? "üîÅ ON" : "üîÅ OFF";
};
	window.addEventListener("DOMContentLoaded", () => {
    checkSoundTouchPresence();
		transposeValue.textContent = pitchSlider.value;
tempoValue.textContent = `${tempoSlider.value}%`;
});
	
function disableMusicPlayerUI(disabled) {
    const controls = document.querySelectorAll(
        "#musicPanel button, #musicPanel input[type=range]"
    );

    controls.forEach(el => {
        el.disabled = disabled;
        el.style.opacity = disabled ? "0.5" : "1";
    });
}
	
	function checkSoundTouchPresence() {
    const warning = document.getElementById("soundtouchWarning");

    const hasSoundTouch =
        typeof window.SoundTouch === "function" &&
        typeof window.SimpleFilter === "function";

    warning.style.display = hasSoundTouch ? "none" : "block";
    disableMusicPlayerUI(!hasSoundTouch);

    return hasSoundTouch;
}
// ---------- helpers ----------
function fmtTime(sec) {
    sec = Math.max(0, sec);
    const m = Math.floor(sec / 60);
    const s = Math.floor(sec % 60).toString().padStart(2, "0");
    return `${m}:${s}`;
}

function setStateText(text) {
    trackState.textContent = text;
}

function setTimeText(curSec, durSec) {
    trackTime.textContent = `${fmtTime(curSec)} / ${fmtTime(durSec)}`;
}

function clamp(n, a, b) { return Math.max(a, Math.min(b, n)); }

// ---------- SoundTouch buffer source adapter ----------
// SoundTouch.js expects an object with `extract(target, numFrames, position)`
// We feed it from an AudioBuffer.
class BufferSource {
    constructor(audioBuffer) {
        this.buffer = audioBuffer;
        this.channels = audioBuffer.numberOfChannels;
        this.length = audioBuffer.length;
    }

    extract(target, numFrames, position) {
        // position is in frames (samples per channel)
        const available = this.length - position;
        const frames = Math.max(0, Math.min(numFrames, available));

        if (frames <= 0) return 0;

        // target is interleaved stereo float array expected by SoundTouch
        const ch0 = this.buffer.getChannelData(0);
        const ch1 = this.channels > 1 ? this.buffer.getChannelData(1) : ch0;

        let out = 0;
        for (let i = 0; i < frames; i++) {
            const idx = position + i;
            target[out++] = ch0[idx];
            target[out++] = ch1[idx];
        }
        return frames;
    }
}

// ---------- build / rebuild processing graph ----------
function buildGraphFromPosition() {
    if (!musicBuffer) return;

    // tear down existing
    teardownGraph();

    soundTouch = new SoundTouch(musicCtx.sampleRate);

    // true controls:
    soundTouch.pitchSemitones = Number(pitchSlider.value);
    soundTouch.tempo = Number(tempoSlider.value) / 100;

    const src = new BufferSource(musicBuffer);
    filter = new SimpleFilter(src, soundTouch);

    // Seek by setting sourcePosition (in samples/frames)
    filter.sourcePosition = Math.floor(positionSamples);

    processor = musicCtx.createScriptProcessor(4096, 0, 2);

    processor.onaudioprocess = (e) => {
    const outL = e.outputBuffer.getChannelData(0);
    const outR = e.outputBuffer.getChannelData(1);

    const numFrames = outL.length;

    // SoundTouch expects an interleaved Float32Array
    const interleaved = new Float32Array(numFrames * 2);

    const frames = filter.extract(interleaved, numFrames);

   if (frames === 0) {
    if (repeatEnabled && musicBuffer) {
        // restart from beginning
        positionSamples = 0;
        buildGraphFromPosition();
        return;
    }

    outL.fill(0);
    outR.fill(0);
    stopMusicHard();
    return;
}

    // De-interleave
    let j = 0;
    for (let i = 0; i < numFrames; i++) {
        outL[i] = interleaved[j++];
        outR[i] = interleaved[j++];
    }

    positionSamples = filter.sourcePosition;
};

    processor.connect(musicCtx.destination);
    playStartCtxTime = musicCtx.currentTime;
}

// ---------- UI update loop ----------
function updateUI() {
    if (!musicBuffer) return;

    // Throttle UI a bit (smoother + less cost)
    const now = performance.now();
    if (now - lastUiUpdate > 60) {
        const durSec = musicBuffer.duration;
        const curSec = positionSamples / musicBuffer.sampleRate;

        const pct = durSec > 0
            ? clamp((curSec / durSec) * 100, 0, 100)
            : 0;

        seekSlider.value = pct;
        seekPercent.textContent = `${pct.toFixed(1)}%`;

        setTimeText(curSec, durSec);
        lastUiUpdate = now;
    }

    if (isMusicPlaying) {
        rafId = requestAnimationFrame(updateUI);
    }
}

// ---------- load file ----------
musicInput.onchange = async () => {
    const file = musicInput.files[0];
    if (!file) return;

    currentTrackName = file.name; // ‚úÖ store filename

    // Ensure context is ready (some browsers need user gesture; file pick counts)
    if (musicCtx.state === "suspended") {
        try { await musicCtx.resume(); } catch {}
    }

    // Stop any playback
    stopMusicHard();

    const arr = await file.arrayBuffer();
    musicBuffer = await musicCtx.decodeAudioData(arr);

    positionSamples = 0;
    seekSlider.value = 0;
    pitchSlider.value = 0;
    tempoSlider.value = 100;
	transposeValue.textContent = pitchSlider.value;
    tempoValue.textContent = `${tempoSlider.value}%`;
    setStateText("Ready");
    setTimeText(0, musicBuffer.duration);
	
};

// ---------- play / pause ----------
playBtn.onclick = async () => {
    if (!musicBuffer) return;

    if (musicCtx.state === "suspended") {
        try { await musicCtx.resume(); } catch {}
    }

    if (!isMusicPlaying) {
        buildGraphFromPosition();
        isMusicPlaying = true;
        playBtn.textContent = "‚è∏Ô∏è";
        setStateText(`Playing: ${currentTrackName}`);
        cancelAnimationFrame(rafId);
        rafId = requestAnimationFrame(updateUI);
    } else {
        // Pause = disconnect processor but keep positionSamples
        isMusicPlaying = false;
        playBtn.textContent = "‚ñ∂Ô∏è";
        setStateText(`Paused: ${currentTrackName}`);
        teardownGraph(); // stops processing immediately
        cancelAnimationFrame(rafId);
        rafId = null;
        updateUI(); // one last update
    }
};

// ---------- stop ----------
stopBtn.onclick = () => {
    stopMusicHard();
};

function stopMusicHard() {
    isMusicPlaying = false;
    playBtn.textContent = "‚ñ∂Ô∏è";
    setStateText("Stopped");
    teardownGraph();
    cancelAnimationFrame(rafId);
    rafId = null;

    if (musicBuffer) {
        positionSamples = 0;
        seekSlider.value = 0;
		seekPercent.textContent = "0.0%";
        setTimeText(0, musicBuffer.duration);
    } else {
        seekSlider.value = 0;
		seekPercent.textContent = "0.0%";
        setTimeText(0, 0);
    }
}

function teardownGraph() {
    if (processor) {
        try { processor.disconnect(); } catch {}
        processor.onaudioprocess = null;
        processor = null;
    }
    filter = null;
    soundTouch = null;
}

// ---------- seeking ----------
let isDraggingSeek = false;

seekSlider.addEventListener("pointerdown", () => { isDraggingSeek = true; });
seekSlider.addEventListener("pointerup", () => {
    isDraggingSeek = false;
});

seekSlider.oninput = () => {
    if (!musicBuffer) return;

    const pct = Number(seekSlider.value);
    seekPercent.textContent = `${pct.toFixed(1)}%`;

    const duration = musicBuffer.duration;
    const targetSec = (pct / 100) * duration;
    positionSamples = Math.floor(
        targetSec * musicBuffer.sampleRate
    );

    if (isMusicPlaying) {
        buildGraphFromPosition();
    } else {
        setTimeText(targetSec, duration);
    }
};

// ---------- pitch / tempo (true SoundTouch controls) ----------
pitchSlider.oninput = () => {
    const v = Number(pitchSlider.value);
    transposeValue.textContent = v;
    if (soundTouch) soundTouch.pitchSemitones = v;
};

tempoSlider.oninput = () => {
    const v = Number(tempoSlider.value);
    tempoValue.textContent = `${v}%`;
    if (soundTouch) soundTouch.tempo = v / 100;
};
const bubbleHexOverlay = document.getElementById('bubbleHexOverlay');

function showHexOverlay(text, color, x, y) {
    bubbleHexOverlay.textContent = text;
    bubbleHexOverlay.style.color = color || "#ffffff";
    bubbleHexOverlay.style.left = `${x + 12}px`;
    bubbleHexOverlay.style.top = `${y + 12}px`;
    bubbleHexOverlay.style.display = 'block';
}

function hideHexOverlay() {
    bubbleHexOverlay.style.display = 'none';
}

function loadStats() {
    const saved = localStorage.getItem("bubbleShooterStats");
    return saved ? JSON.parse(saved) : { ...DEFAULT_STATS };
}

function saveStats() {
    localStorage.setItem("bubbleShooterStats", JSON.stringify(stats));
}

let stats = loadStats();
	window.addEventListener("DOMContentLoaded", updateStatsBoard);
    window.addEventListener('DOMContentLoaded', () => {
        console.log(
            "%cWelcome to SK's Bubble Shooter HTML game!",
            "color: #00ffcc; font-size: 16px; font-weight: bold;"
        );
    });

function resetStats() {
    const ok = confirm(
        "Reset ALL player stats?\n" +
        "This cannot be undone!"
    );

    if (!ok) return;

    stats = { ...DEFAULT_STATS };
    saveStats();
    updateStatsBoard();

    console.log("Player stats reset.");
}
    document.fonts.load("20px Storopia");
    // --- SETTINGS & AUDIO ---
let soundEnabled = localStorage.getItem('bubbleSoundEnabled') !== 'false'; 
let autosaveEnabled = localStorage.getItem('bubbleAutosaveEnabled') === 'true';
    let customLevelName = "";
    let isLoadingSave = false;
const PERFECT_BASE_SCORE = 1000;
const PERFECT_AMMO_BONUS = 100;
let absorbFallingBubbles = false;
let customAuthorName = "";
let isCampaignMode = false;
    let campaignLevel = 1;
    let campaignTimer = 0;
    const COLORLESS_CHANCE = 0.10;
    let lastTickSecond = null;
    let lastTimeMs = performance.now();
    let campaignTimerAcc = 0; // accumulator for 1-second ticks (optional)
    const CAMPAIGN_TOTAL_LEVELS = 20;
    let loadedProgressOverride = null;
    const CAMPAIGN_TIME_LIMIT = 300; // 5 minutes in seconds
    const COLORLESS = null;
let levelPattern = 0;
    let panicMode = false;
let panicFlash = false;
let panicTimer = 0;
  let panicTriggered = false;  
  let mouseX = 0;
let mouseY = 0;
let aimEnabled = localStorage.getItem('bubbleAimEnabled') !== 'false';
let lastShotBubbleCount = 0;
let campaignFinished = false;
let lastShotWasMatch = false;
let lastShotUsedFinalAmmo = false;
let lastClearWasPerfect = false;
let visualiseBubbleColour = false;
let lives = 5;           // default
let DEFAULT_LIVES = lives
let suppressAutosaveOnce = false;
let MAX_LIVES = 100;
let lastLifePulseSecond = null;
let lastHeartbeatSecond = null;
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
let panicPulseTime = 0;
let panicFade = 0; // 0 = invisible, 1 = full panic
let isAiming = false;
let aimGlowPulse = 0;
let dragBubblesEnabled = false;
let snapPreview = null;
let snapIsValidMatch = false;
let draggedBubble = null;   // reference or temp object
let dragSource = null;      // 'grid' | 'current' | 'next'
let snapWillFall = false;
const DRAG_EMOJI = "üß≤";

function setCanvasGlow(size, color) {
    canvas.style.setProperty("--glow-size", `${size}px`);
    canvas.style.setProperty("--glow-color", color);
}

function setBrowserTitle(text) {
    document.title = text;
}

function setMenuDesc(text) {
    document.getElementById('menuDescription').innerText = text;
}

function clearMenuDesc() {
    document.getElementById('menuDescription').innerText =
        "";
}
    function updateStatsBoard() {
    const el = document.getElementById("statsContent");
    if (!el) return;

    el.innerHTML = `
    Levels Completed: <b>${fmt(stats.levelsCompleted)}</b><br>
	Levels Completed Perfectly: <b>${fmt(stats.levelsCompletedPerfectly)}</b><br>
    Levels Failed: <b>${fmt(stats.levelsFailed)}</b><br>
    Campaign Wins: <b>${fmt(stats.campaignWins)}</b><br><br>

    Bubbles Shot: <b>${fmt(stats.bubblesShot)}</b><br>
    Bubbles Swapped: <b>${fmt(stats.bubblesSwapped)}</b><br>
	Bubbles Popped: <b>${fmt(stats.bubblesPopped)}</b><br>
	Bubbles Dropped: <b>${fmt(stats.bubblesDropped)}</b><br><br>

    Max Streak: <b>${fmt(stats.totalStreak)}</b><br>
    Max Perfect Streak: <b>${fmt(stats.perfectStreak)}</b><br><br>

    Puzzle Mode Played: <b>${fmt(stats.puzzlePlays)}</b><br>
    Campaign Mode Played: <b>${fmt(stats.campaignPlays)}</b><br>
    Custom Mode Played: <b>${fmt(stats.customPlays)}</b><br><br>
    Total Lives Gained: <b>${fmt(stats.livesGained)}</b><br>
    Total Lives Lost: <b>${fmt(stats.livesLost)}</b><br><br>

    Debug Commands Used: <b>${fmt(stats.debugCommandsUsed)}</b><br><br>
	
    High Score: <b>${fmt(stats.highScore)}</b>
    `;
}
function updateLivesUI() {
    const outer = document.getElementById('livesDisplay');
    const inner = document.getElementById('livesInner');
    if (!outer || !inner) return;

    outer.style.display = "inline";

    if (isPlaytesting) {
        inner.innerText = "‚ù§Ô∏è-";
        inner.style.color = "#888";
        outer.classList.remove('low-lives');
        return;
    }

   else if (lives === 0)
    {
        inner.innerText = `üíî${lives}`;
    }
    else
    {
    inner.innerText = `‚ù§Ô∏è${lives}`;
    }
    if (lives <= 1) {
        inner.style.color = "#8b0000";
    } else if (lives < 4) {
        inner.style.color = "#ff0000";
    } else {
        inner.style.color = "#00ff00";
    }

    if (lives < 4) {
        outer.classList.add('low-lives');
    } else {
        outer.classList.remove('low-lives');
    }
}

function updateSoundButton() {
    const btn = document.getElementById('soundToggle');
    if(btn) {
        btn.innerText = soundEnabled ? "üîä Sound: ON" : "üîá Sound: OFF";
        btn.style.background = soundEnabled ? "#555" : "#333";
    }
}
    
function updateAutosaveButton() {
    const btn = document.getElementById('autosaveToggle');
    if(btn) {
        btn.innerText = autosaveEnabled ? "üíæ Autosave: ON" : "üíæ Autosave: OFF";
        btn.style.background = autosaveEnabled ? "#4CAF50" : "#444";
    }
}

function addSfxButtonToMenu() {
    const menu = document.getElementById('mainMenu');
    if (document.getElementById('sfxMenuBtn')) return;

    const btn = document.createElement('button');
    btn.id = 'sfxMenuBtn';
    btn.innerText = 'üéµ SFX TESTER';
    btn.style.background = '#00e5ff';
    btn.style.color = '#000';
    btn.style.fontWeight = 'bold';

    btn.onclick = openSfxMenu;
    btn.onmouseenter = () =>
        setMenuDesc("SFX Tester: Opens a menu to test in-game sound effects.");
    btn.onmouseleave = clearMenuDesc;

    menu.appendChild(document.createElement('br'));
    menu.appendChild(btn);
}

function toggleSound() {
    soundEnabled = !soundEnabled;
    localStorage.setItem('bubbleSoundEnabled', soundEnabled);
    updateSoundButton();
}

function toggleAutosave() {
    autosaveEnabled = !autosaveEnabled;
    localStorage.setItem('bubbleAutosaveEnabled', autosaveEnabled);
    updateAutosaveButton();
}

updateSoundButton();
updateAutosaveButton();
updateAimButton();


function toggleAim() {
    aimEnabled = !aimEnabled;
    localStorage.setItem('bubbleAimEnabled', aimEnabled);
    updateAimButton();
}

function updateAimButton() {
    const btn = document.getElementById('aimToggle');
    if (!btn) return;
    btn.innerText = aimEnabled ? "üéØ ON" : "üéØ OFF";
    btn.style.borderColor = aimEnabled ? "#00ffcc" : "#555";
}

const sounds = {
    play(type) {
        if (!soundEnabled) return;
        if (audioCtx.state === 'suspended') audioCtx.resume();

        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain);
        gain.connect(audioCtx.destination);

        const now = audioCtx.currentTime;

        if (type === 'shoot') {
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(150, now);
            osc.frequency.exponentialRampToValueAtTime(40, now + 0.1);
            gain.gain.setValueAtTime(0.1, now);
            gain.gain.linearRampToValueAtTime(0, now + 0.1);
            osc.start(); osc.stop(now + 0.1);

        } else if (type === 'pop') {
    osc.type = 'triangle';                 // soft but punchy
    osc.frequency.setValueAtTime(700, now);
    osc.frequency.exponentialRampToValueAtTime(80, now + 0.07);

    gain.gain.setValueAtTime(0.12, now);
    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.07);

    osc.start();
    osc.stop(now + 0.07);

        } else if (type === 'bounce') {
            osc.type = 'sine';
            osc.frequency.setValueAtTime(200, now);
            gain.gain.setValueAtTime(0.05, now);
            gain.gain.linearRampToValueAtTime(0, now + 0.05);
            osc.start(); osc.stop(now + 0.05);

        } else if (type === 'place') {
            osc.type = 'sine';
            osc.frequency.setValueAtTime(100, now);
            gain.gain.setValueAtTime(0.1, now);
            gain.gain.linearRampToValueAtTime(0, now + 0.08);
            osc.start(); osc.stop(now + 0.08);

        } else if (type === 'swap') {
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(300, now);
            osc.frequency.linearRampToValueAtTime(600, now + 0.05);
            gain.gain.setValueAtTime(0.05, now);
            gain.gain.linearRampToValueAtTime(0, now + 0.05);
            osc.start(); osc.stop(now + 0.05);

        } else if (type === 'fall') {
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(100, now);
            osc.frequency.linearRampToValueAtTime(20, now + 0.3);
            gain.gain.setValueAtTime(0.05, now);
            gain.gain.linearRampToValueAtTime(0, now + 0.3);
            osc.start(); osc.stop(now + 0.3);

        } else if (type === 'win') {
            [440, 554, 659, 880].forEach((f, i) => {
                const o = audioCtx.createOscillator();
                const g = audioCtx.createGain();
                o.connect(g); g.connect(audioCtx.destination);
                o.frequency.setValueAtTime(f, now + i * 0.1);
                g.gain.setValueAtTime(0.08, now + i * 0.1);
                g.gain.linearRampToValueAtTime(0, now + i * 0.4);
                o.start(now + i * 0.1);
                o.stop(now + i * 0.4);
            });

        } else if (type === 'fail') {
            osc.type = 'square';
            osc.frequency.setValueAtTime(100, now);
            osc.frequency.linearRampToValueAtTime(30, now + 0.5);
            gain.gain.setValueAtTime(0.1, now);
            gain.gain.linearRampToValueAtTime(0, now + 0.5);
            osc.start(); osc.stop(now + 0.5);

         } else if (type === 'panic') {
    osc.type = 'sine';                     // softer waveform
    osc.frequency.setValueAtTime(650, now); // less piercing
    gain.gain.setValueAtTime(0.025, now);  // WAY quieter
    gain.gain.linearRampToValueAtTime(0, now + 0.18);
    osc.start();
    osc.stop(now + 0.18);
}
    else if (type === 'tick') {
        osc.type = 'square';
        osc.frequency.setValueAtTime(800, now);
        gain.gain.setValueAtTime(0.03, now);
        gain.gain.linearRampToValueAtTime(0, now + 0.08);
        osc.start();
        osc.stop(now + 0.08);
        
    }
else if (type === 'heartbeat') {
    osc.type = 'triangle';                 // stronger body than sine
    osc.frequency.setValueAtTime(90, now); // higher = more audible
    osc.frequency.exponentialRampToValueAtTime(45, now + 0.2);

    gain.gain.setValueAtTime(0.28, now);   // üî• louder
    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.35);

    osc.start();
    osc.stop(now + 0.35);
}



    }
};
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

const RADIUS = 20;
const ROW_HEIGHT = 34;
const DEADLINE = 520;

const ALL_COLORS = [
    '#FF0000', // strong red
    '#FF9500', // orange
    '#FFCC00', // yellow
    '#34C759', // green
    '#00C7BE', // teal
    '#007AFF', // blue
    '#5856D6', // indigo
    '#AF52DE', // purple
    '#FF2D55', // pink
    '#8E8E93', // grey
    '#A2845E', // brown (visible, not muddy)
    '#FFFFFF'  // white
];

const COLOR_EMOJIS = {
    '#FF0000': 'üî¥',
    '#FF9500': 'üü†',
    '#FFCC00': 'üü°',
    '#34C759': 'üü¢',
    '#00C7BE': 'üîµ',
    '#007AFF': 'üî∑',
    '#5856D6': 'üü£',
    '#AF52DE': 'üü™',
    '#FF2D55': 'üíó',
    '#8E8E93': '‚ö™',
    '#A2845E': 'üü§',
    '#FFFFFF': '‚¨ú'
};


let mode = 'puzzle', score = 0, level = 1, angle = 0, mouseInside = false;
let bubbles = [], fallingBubbles = [], projectiles = [], particles = [], floatingScores = [], confetti = [];
let currentBall = '', nextBall = '', ammo = 0, initialBubbleCount = 0;
let streakCount = 1, streakTimer = 0, streakFrozen = false;
const STREAK_DURATION = 180;
let gameOver = false, gameWin = false, gameRunning = false, isPaused = false;
let gameOverReason = ""; 
let animationId = null, isCustomMode = false, isPlaytesting = false, customLevelSnapshot = [];
let selectedColor = ALL_COLORS[0];
let perfectStreak = 0;

function updateFavicon(color) {
    const favicon = document.getElementById('dynamicFavicon');

    const svgIcon =
        `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100">
            <circle cx="50" cy="50" r="45"
                fill="${color}"
                stroke="white"
                stroke-width="8"/>
        </svg>`;

    favicon.href = 'data:image/svg+xml,' + encodeURIComponent(svgIcon);
}
    
    function setFaviconEmoji(emoji) {
    const favicon = document.getElementById('dynamicFavicon');
    favicon.href =
        'data:image/svg+xml,' +
        '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100">' +
        `<text y=".9em" font-size="90">${emoji}</text>` +
        '</svg>#' + Math.random(); // force refresh
}
function startCampaign() {
        lives = DEFAULT_LIVES;
        updateLivesUI();
        stats.campaignPlays++;
        saveStats();
        setBrowserTitle("üèÜ SK's Bubble Shooter ‚Äî Campaign Mode");
        isCampaignMode = true;
        campaignLevel = 1;
        campaignTimer = CAMPAIGN_TIME_LIMIT;
        lastTimeMs = performance.now(); // ‚úÖ reset timer baseline
        startMode('puzzle');
    }

function refreshFavicon() {

    if (gameWin) {
        setFaviconEmoji("‚úÖ");
        return;
    }

    if (gameOver) {
        setFaviconEmoji("‚ùå");
        return;
    }

    if (isPaused) {
        setFaviconEmoji("‚è∏Ô∏è");
        return;
    }

    if (panicMode) {
        setFaviconEmoji("‚ö†Ô∏è");
        return;
    }

    updateFavicon(currentBall);
}
    
function updatePanicState() {
    if (isPaused || isCustomMode || gameOver || gameWin) {
        panicMode = false;
        panicTriggered = false;
        refreshFavicon();
        return;
    }

    const nearRedLine = bubbles.some(b => b.y > DEADLINE - 60);
    const lowAmmo = ammo < 10;
    const lowLives = lives > 0 && lives <= 3;

    const timerPanic =
        isCampaignMode && Math.ceil(campaignTimer) <= 20;

    const shouldPanic =
        nearRedLine || lowAmmo || timerPanic || lowLives;

    if (shouldPanic && !panicMode) {
        panicMode = true;

        if (!panicTriggered) {
            sounds.play('panic'); // plays ONCE
            panicTriggered = true;
        }

        refreshFavicon();
        return;
    }

    if (!shouldPanic && panicMode) {
        panicMode = false;
        panicTriggered = false;
        refreshFavicon();
    }
}


function openDebug() { document.getElementById('debugConsole').style.display = 'block'; document.getElementById('debugInput').value = ''; document.getElementById('debugInput').focus(); setPause(true); }

window.addEventListener('keydown', e => {
    if (e.key === 'Escape') togglePause();
    if (e.ctrlKey && e.shiftKey && e.key.toLowerCase() === 'c') { e.preventDefault(); openDebug(); }
});

document.getElementById('debugInput').addEventListener('keydown', e => {
    if (e.key === 'Enter') {
	stats.debugCommandsUsed++;
    saveStats();
        const rawInput = e.target.value.trim();
        const args = rawInput.split(' ');
        const cmd = args[0].toLowerCase();
        const arg = args[1];
		const val = Number(arg);


        if (cmd === '!completelevel') { 
            bubbles = []; 
            triggerWin(); 
        } 
        else if (cmd === '!setammo' && !isNaN(val)) { 
            ammo = val; 
        } 
        else if (cmd === '!setstreak' && !isNaN(val)) { 
            streakCount = val; 
            streakTimer = STREAK_DURATION; 
        } 
        else if (cmd === '!freezestreaktimer') { 
            streakFrozen = true; 
        }
        else if (cmd === '!unfreezestreaktimer') { 
            streakFrozen = false; 
        }
        else if (cmd === '!faillevel') {
            triggerFail("You used the !faillevel debug command.\n-1‚ù§Ô∏è");
        }
        else if (cmd === '!advancelevel' && !isNaN(val)) {
            level = val;
            startMode('puzzle', false, true);
        }

        else if (cmd === '!advancecampaignlevel' && !isNaN(val)) {

            if (!isCampaignMode) {
                alert("You must be in campaign mode to use this command.");
                return;
            }

            // üöÄ If value is ABOVE max ‚Üí instantly win campaign
            if (val > CAMPAIGN_TOTAL_LEVELS) {

                campaignLevel = CAMPAIGN_TOTAL_LEVELS + 1;
                campaignTimer = 0;
                lastTickSecond = null;

                gameWin = true;
                isCampaignMode = false;

                sounds.play('win');
                refreshFavicon();

                return;
            }

            // üîí Clamp between 1 and max
            const target = Math.max(1, Math.min(CAMPAIGN_TOTAL_LEVELS, val));

            // üéÅ Reward ammo like normal campaign clear
            ammo += 50;

            campaignLevel = target;
            campaignTimer = CAMPAIGN_TIME_LIMIT;
            lastTickSecond = null;

            // Load that campaign stage
            suppressAutosaveOnce = true;
            startMode('puzzle', false, true);
        }
else if (cmd === '!setperfectstreak' && !isNaN(val)) {
    perfectStreak = Math.max(0, val);
    console.log(`Perfect streak set to x${perfectStreak}`);
}

else if (cmd === '!addcampaigntime' && !isNaN(val)) {

    if (!isCampaignMode) {
        alert("You must be in campaign mode to use this command.");
        return;
    }

    // ‚è±Ô∏è Add seconds (can be negative)
    campaignTimer += val;

    // üîí Clamp so it never goes below 0
    if (campaignTimer < 0) {
        campaignTimer = 0;
    }

    // üîî Reset tick state so warning sounds/glow resync properly
    lastTickSecond = null;

    console.log(`Campaign time adjusted by ${val}s. New time: ${Math.ceil(campaignTimer)}s`);
	
}
else if (cmd === '!setcurrentbubble') {

    if (!arg || !isValidHexColor(arg) || !colorExists(arg)) {
        alert("Invalid colour.");
        return;
    }

    currentBall = arg.toUpperCase();
    refreshFavicon();
}

else if (cmd === '!setnextbubble') {

    if (!arg || !isValidHexColor(arg) || !colorExists(arg)) {
        alert("Invalid colour.");
        return;
    }

    nextBall = arg.toUpperCase();
}
else if (cmd === '!showcoloursashex') {

    const list = ALL_COLORS.join('\n');

    alert(
        "Available Colours (Hex):\n\n" + list
    );
}
else if (cmd === '!visualisebubblecolour') {

    if (arg !== 'true' && arg !== 'false') {
        alert("Usage: !visualisebubblecolour true/false");
        return;
    }

    visualiseBubbleColour = (arg === 'true');

    alert(
        `Bubble colour visualisation ` +
        (visualiseBubbleColour ? "ENABLED" : "DISABLED")
    );
}
    else if (cmd === '!setlives' && !isNaN(val)) {
    lives = Math.max(0, Math.min(MAX_LIVES, val));
    updateLivesUI();
    console.log(`Lives set to ${lives}`);
    }
    else if (cmd === '!dragbubbles') {
    if (arg !== 'true' && arg !== 'false') {
        alert("Usage: !dragbubbles true/false");
        return;
    }

    dragBubblesEnabled = (arg === 'true');

    alert(
        `Drag Bubbles: ${dragBubblesEnabled ? "ENABLED" : "DISABLED"}`
    );
    canvas.style.cursor = dragBubblesEnabled ? "none" : "cell";
}

    else if (cmd === '!absorbfallingbubbles') {
    if (arg === 'true') {
        absorbFallingBubbles = true;
        console.log('Absorb falling bubbles: ENABLED');
    } else if (arg === 'false') {
        absorbFallingBubbles = false;
        console.log('Absorb falling bubbles: DISABLED');
    } else {
        console.log('Usage: !absorbfallingbubbles true/false');
    }
    
}
    e.target.value = '';
        document.getElementById('debugConsole').style.display = 'none';
        setPause(false);
    }

});

function isValidHexColor(hex) {
    return /^#[0-9A-Fa-f]{6}$/.test(hex);
}

function colorExists(hex) {
    return ALL_COLORS.includes(hex.toUpperCase());
}
function getHoveredBubble() {
    for (let b of bubbles) {
        if (Math.hypot(mouseX - b.x, mouseY - b.y) <= RADIUS) {
            return b;
        }
    }
    return null;
}
function drawBubbleHexLabel(text, color, x, y) {
    ctx.save();

    ctx.font = "14px Storopia";
    ctx.textAlign = "left";
    ctx.textBaseline = "top";

    const padding = 6;
    const width = ctx.measureText(text).width + padding * 2;

    // background
    ctx.fillStyle = "rgba(0,0,0,0.75)";
    ctx.fillRect(x, y, width, 22);

    // text colour = bubble colour
    ctx.fillStyle = color || "#ffffff";
    ctx.fillText(text, x + padding, y + 4);

    ctx.restore();
}
function isHoveringCurrentBubble() {
    const cx = canvas.width / 2;
    const cy = canvas.height - 80;
    return Math.hypot(mouseX - cx, mouseY - cy) <= RADIUS;
}

function isHoveringNextBubble() {
    if (ammo <= 1) return false;
    const nx = canvas.width / 2 + 60;
    const ny = canvas.height - 80;
    return Math.hypot(mouseX - nx, mouseY - ny) <= RADIUS * 0.7;
}

window.addEventListener('mousemove', e => {
    const rect = canvas.getBoundingClientRect();
    mouseX = e.clientX - rect.left;
    mouseY = e.clientY - rect.top;

    angle = Math.atan2(
        mouseY - (canvas.height - 80),
        mouseX - (canvas.width / 2)
    );

    if (dragBubblesEnabled && draggedBubble) {
        // snap preview
        snapPreview = getSnapPreview(mouseX, mouseY);

        // occupied check (ignore the bubble you're moving if it's a grid bubble)
        const ignore = (dragSource === 'grid') ? draggedBubble : null;
        const occupied = isCellOccupied(snapPreview.row, snapPreview.col, ignore);
        snapPreview.occupied = occupied;

        if (!snapPreview.occupied && draggedBubble.color) {
    const testBubble = {
        x: snapPreview.x,
        y: snapPreview.y,
        row: snapPreview.row,
        col: snapPreview.col,
        color: draggedBubble.color
    };

    snapIsValidMatch = findMatches(testBubble).length >= 3;

    // üß≤ check support (will it fall?)
    snapWillFall = !snapIsValidMatch && !isBubbleSupported(testBubble);
} else {
    snapIsValidMatch = false;
    snapWillFall = false;
}
    }
});



let colorblindMode = localStorage.getItem('bubbleColorblind') === 'true';

function updateColorblindButton() {
    const btn = document.getElementById('colorblindToggle');
    if (!btn) return;
    btn.innerText = colorblindMode ? "üëÅÔ∏è ON" : "üëÅÔ∏è OFF";
    btn.style.borderColor = colorblindMode ? "#00ffcc" : "#555";
}


function toggleColorblind() {
    colorblindMode = !colorblindMode;
    localStorage.setItem('bubbleColorblind', colorblindMode);
    updateColorblindButton();
}

updateColorblindButton();

canvas.addEventListener('mousedown', e => {
    // Right-click: swap (keep)
    if (e.button === 2) {
        e.preventDefault();
        swapBubbles();
        return false;
    }

    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;

    // ‚úÖ DRAG MODE PICKUP
    if (dragBubblesEnabled && !isPaused && !gameOver && !gameWin) {
        // pick grid bubble
        const gridBubble = bubbles.find(b => Math.hypot(mx - b.x, my - b.y) <= RADIUS);
        if (gridBubble) {
            draggedBubble = gridBubble;
            dragSource = 'grid';
            snapPreview = getSnapPreview(mx, my);
            return; // IMPORTANT: don't shoot / editor place
        }

        // pick current bubble (drag copy)
        if (isHoveringCurrentBubble()) {
            draggedBubble = { color: currentBall };
            dragSource = 'current';
            snapPreview = getSnapPreview(mx, my);
            return;
        }

        // pick next bubble (drag copy)
        if (isHoveringNextBubble()) {
            draggedBubble = { color: nextBall };
            dragSource = 'next';
            snapPreview = getSnapPreview(mx, my);
            return;
        }
    }

    // -----------------------------
    // CUSTOM EDITOR CLICK BEHAVIOR
    // -----------------------------
    if (isCustomMode) {
        let r = Math.round((e.clientY - rect.top - RADIUS) / ROW_HEIGHT);
        let off = (r % 2 === 0) ? 0 : RADIUS;
        let c = Math.round((e.clientX - rect.left - RADIUS - off) / (RADIUS * 2));

        const idx = bubbles.findIndex(b => b.row === r && b.col === c);

        // Click existing bubble = remove it
        if (idx !== -1) {
            bubbles.splice(idx, 1);
        }
        // Click empty spot = place it (limit rows)
        else if (r >= 0 && r < 13) {
            let co = getGridCoords(r, c);

            // If you want "true colorless" like your save file (missing color field),
            // do NOT store color when selectedColor is null.
            const bubble = { x: co.x, y: co.y, row: r, col: c };
            if (selectedColor) bubble.color = selectedColor; // only store when colored

            bubbles.push(bubble);
        }

        // IMPORTANT: stop here so editor clicks do NOT shoot / advance levels
        return;
    }

    // -----------------------------
    // NORMAL GAME CLICK BEHAVIOR
    // -----------------------------
    if (!gameRunning) return;

    if (isPaused) {
        setPause(false);
        return;
    }

    // If level ended, click advances (your existing logic)
    if (gameOver || gameWin) {

        if (isPlaytesting) {
            bubbles = JSON.parse(JSON.stringify(customLevelSnapshot));
            enterCustomEditor();
            return;
        }

        if (gameWin) {

            if (isCampaignMode) {

                if (campaignLevel >= CAMPAIGN_TOTAL_LEVELS) {
                    isCampaignMode = false;
                    campaignLevel = 1;
                    return;
                }

                campaignLevel++;
                campaignTimer = 300;
                suppressAutosaveOnce = true;
                startMode('puzzle', false, true);

                // reward ammo AFTER new level loads
                ammo += 50;
                updateAmmo();
                return;
            }

            level++;
            startMode('puzzle', false, true);
            return;
        }

        if (gameOver) {

            if (isCampaignMode)
        {
            campaignTimer = CAMPAIGN_TIME_LIMIT;
        }
            
    // üíÄ True game over ‚Üí back to menu
    if (lives <= 0) {
        exitToMenu();
        return;
    }

    // üîÅ Retry same level
    gameOver = false;
    gameWin = false;
    suppressAutosaveOnce = true;
    startMode('puzzle', false, true);
    initializeAmmo("puzzleNew");
    return;
        }
    }

    // only allow shooting when cursor is valid (same rule as aim visualiser)
   if (e.button === 0) {
    isAiming = true;
}
});
function isBubbleSupported(bubble) {
    // Top row is always supported
    if (bubble.row === 0) return true;

    // Adjacent positions (hex grid)
    const neighbors = bubbles.filter(b =>
        Math.abs(b.row - bubble.row) <= 1 &&
        Math.abs(b.col - bubble.col) <= 1 &&
        b !== bubble
    );

    return neighbors.length > 0;
}

canvas.addEventListener('mouseup', e => {
    if (e.button !== 0) return;

    // ‚úÖ If dragging, handle drop FIRST and exit (so no shooting happens)
    if (dragBubblesEnabled && draggedBubble && snapPreview) {
        const ignore = (dragSource === 'grid') ? draggedBubble : null;
        const occupied = isCellOccupied(snapPreview.row, snapPreview.col, ignore);

        if (!occupied) {
            const placed = {
                x: snapPreview.x,
                y: snapPreview.y,
                row: snapPreview.row,
                col: snapPreview.col,
                color: draggedBubble.color
            };

            // If match would happen, pop using existing logic
            if (placed.color && findMatches(placed).length >= 3) {
                if (placed.color) {
    const matches = findMatches(placed);

    if (matches.length >= 3) {

        // üßπ REMOVE ORIGINAL GRID BUBBLE
        if (dragSource === 'grid') {
            const idx = bubbles.indexOf(draggedBubble);
            if (idx !== -1) bubbles.splice(idx, 1);
        }

        popBubbles(matches);
    }
}
            } else {
                // Otherwise snap/move
                if (dragSource === 'grid') {
    draggedBubble.x = placed.x;
    draggedBubble.y = placed.y;
    draggedBubble.row = placed.row;
    draggedBubble.col = placed.col;

    // ‚ùå Unsupported ‚Üí fall (no points)
    if (!isBubbleSupported(draggedBubble)) {
        const idx = bubbles.indexOf(draggedBubble);
        if (idx !== -1) bubbles.splice(idx, 1);

        fallingBubbles.push({
            x: placed.x,
            y: placed.y,
            vx: (Math.random() - 0.5) * 2,
            vy: 2,
            rot: 0,
            rotSpeed: (Math.random() - 0.5) * 0.2,
            color: draggedBubble.color
        });

        sounds.play('fall');
    }
}
 else {
    // Place bubble temporarily
    bubbles.push(placed);

    // ‚ùå Not supported ‚Üí FALL (no points)
    if (!isBubbleSupported(placed)) {
        const idx = bubbles.indexOf(placed);
        if (idx !== -1) bubbles.splice(idx, 1);

        fallingBubbles.push({
            x: placed.x,
            y: placed.y,
            vx: (Math.random() - 0.5) * 2,
            vy: 2,
            rot: 0,
            rotSpeed: (Math.random() - 0.5) * 0.2,
            color: placed.color
        });

        sounds.play('fall');
    }
}
            }
        }

        // cleanup
        draggedBubble = null;
        dragSource = null;
        snapPreview = null;
        snapIsValidMatch = false;

        isAiming = false;
        return; // IMPORTANT: do not shoot
    }

    // ‚úÖ Normal shooting (your existing logic)
    if (
        isAiming &&
        gameRunning &&
        !isPaused &&
        !gameOver &&
        !gameWin &&
        ammo > 0 &&
        mouseX >= 0 &&
        mouseX <= canvas.width &&
        mouseY >= 0 &&
        mouseY <= DEADLINE
    ) {
        shoot();
    }

    isAiming = false;
});
canvas.addEventListener('mouseleave', () => {
    isAiming = false;
});

function setPause(state) {
    isPaused = state;
    document.getElementById('pauseBtn').innerText = isPaused ? "RESUME" : "PAUSE";
    refreshFavicon();
}
function togglePause() { if(!gameRunning || gameOver || gameWin) return; setPause(!isPaused); }

function shoot() {
   loadedProgressOverride = null;

     // üîí Freeze shot conditions
    lastShotWasMatch = false;
    lastShotUsedFinalAmmo = (ammo === 1);
    lastShotBubbleCount = bubbles.length;

    if (projectiles.length > 0 || ammo <= 0) return;
    sounds.play('shoot');

    projectiles.push({
        x: canvas.width / 2,
        y: canvas.height - 80,
        dx: Math.cos(angle) * 12,
        dy: Math.sin(angle) * 12,
        color: currentBall
    });

    ammo--;
    currentBall = nextBall;
    stats.bubblesShot++;
saveStats();
    updateAmmo(true); // ‚úÖ ONLY here do we reroll next
}
function snapToGrid(p) {
    p.x -= p.dx * 0.5;
    p.y -= p.dy * 0.5;

    let r = Math.max(0, Math.round((p.y - RADIUS) / ROW_HEIGHT));
    let off = (r % 2 === 0) ? 0 : RADIUS;

    let c = Math.max(
        0,
        Math.min(
            (r % 2 === 0 ? 10 : 9),
            Math.round((p.x - RADIUS - off) / (RADIUS * 2))
        )
    );

    let co = getGridCoords(r, c);

    if (bubbles.some(b => b.row === r && b.col === c)) {
        r++;
        co = getGridCoords(r, c);
    }

    const nb = {
        x: co.x,
        y: co.y,
        row: r,
        col: c,
        color: p.color
    };

    bubbles.push(nb);

let m = findMatches(nb);

if (m.length >= 3) {
    lastShotWasMatch = true; // ‚úÖ mark match
    streakCount++;
    streakTimer = STREAK_DURATION;
    popBubbles(m);
} else {
    lastShotWasMatch = false;
        sounds.play('place');
        if (ammo <= 0 && bubbles.length > 0)
            triggerFail("You ran out of bubbles!\n-1‚ù§Ô∏è");

const beforePct = calcProgressPercent(bubbles.length - 1, initialBubbleCount); 
// bubbles.length already includes the newly placed bubble, so -1 = before placement

updateProgressBar();

const afterPct = calcProgressPercent(bubbles.length, initialBubbleCount);
const diff = +(afterPct - beforePct).toFixed(1);

floatingScores.push({
    x: p.x,
    y: p.y,
    text: `${diff > 0 ? '+' : ''}${diff.toFixed(1)}%`,
    life: 1.0
});


    }
}
function calcProgressPercent(currentCount, initialCount) {
    if (initialCount <= 0) return 100;
    const pct = (Math.max(0, initialCount - currentCount) / initialCount) * 100;
    return +pct.toFixed(1);
}

function popBubbles(m) {
    const beforePct = calcProgressPercent(bubbles.length, initialBubbleCount);

    sounds.play('pop');
	stats.bubblesPopped += m.length;
    saveStats();
    let pts = m.length * 10 * streakCount;
    score += pts;

    m.forEach(b => {
        let idx = bubbles.indexOf(b);
        if (idx > -1) bubbles.splice(idx, 1);

        for (let i = 0; i < 6; i++) {
            particles.push({
                x: b.x, y: b.y,
                vx: (Math.random()-0.5)*8,
                vy: (Math.random()-0.5)*8,
                life: 1.0,
                color: b.color,
                size: Math.random()*3+1
            });
        }
    });

    dropFloatingBubbles();
    updateProgressBar();

    const afterPct = calcProgressPercent(bubbles.length, initialBubbleCount);
    const diff = +(afterPct - beforePct).toFixed(1);

    floatingScores.push({
        x: m[0]?.x || 220,
        y: m[0]?.y || 320,
        text: `+${fmt(pts)} x${fmt(streakCount)}  (${diff > 0 ? '+' : ''}${diff.toFixed(1)}%)`,
        life: 1.0
		
    });

if (bubbles.length === 0) {
    triggerWin();
}


 else if (ammo <= 0) triggerFail("You ran out of bubbles!\n-1‚ù§Ô∏è");
 updateAmmo();
 lastShotWasMatch = false;
}

function fmt(n) {
    return Number(n).toLocaleString();
}

function triggerWin() {

if (!isPlaytesting) {
    const before = lives;
    lives = Math.min(lives + 1, MAX_LIVES);
    if (lives > before) {
        stats.livesGained++;
        saveStats();
    }
}
updateLivesUI();


        if (isCampaignMode) {

            // FINAL LEVEL
            if (campaignLevel >= CAMPAIGN_TOTAL_LEVELS) {

                campaignFinished = true;
                gameWin = true;
     	        stats.campaignWins++;
                saveStats();

               triggerConfetti();
                triggerConfetti();
                sounds.play('win');
                refreshFavicon();
				if (score > stats.highScore) {
                stats.highScore = score;
                }
                return;
            }

            // Normal campaign level clear
            gameWin = true;
            sounds.play('win');
            triggerConfetti();
            refreshFavicon();
            return;
			if (score > stats.highScore) {
    stats.highScore = score;
}
        }

saveStats();
// üéØ PERFECT = last ammo + match + clears board
lastClearWasPerfect =
    lastShotUsedFinalAmmo &&
    lastShotWasMatch &&
    lastShotBubbleCount > 0;

if (
    lastClearWasPerfect &&
    mode !== "custom" &&
    !isPlaytesting
) {
    perfectStreak++;
    stats.levelsCompletedPerfectly++;
	saveStats();
    const bonusScore = PERFECT_BASE_SCORE * perfectStreak;
    score += bonusScore;
    ammo += PERFECT_AMMO_BONUS;
    lives += 10
} else {
    perfectStreak = 0;
}
    stats.levelsCompleted++;
stats.totalStreak = Math.max(stats.totalStreak, streakCount);
stats.perfectStreak = Math.max(stats.perfectStreak, perfectStreak);

// üéÅ Reward bubbles on level completion
if(!isPlaytesting)
{
ammo += 50;
updateLivesUI();
updateAmmo();
}

	if (score > stats.highScore) {
    stats.highScore = score;
}
saveStats();
        gameWin = true;
        sounds.play('win');
        triggerConfetti();
        refreshFavicon();
    }

function triggerFail(reason) {

    if (!isPlaytesting) {
    lives--;
    stats.livesLost++
    }
    saveStats();
    updateLivesUI();


    // üíÄ OUT OF LIVES ‚Üí GAME OVER
    if (lives <= 0) {
        lives = 0;
        gameOver = true;
        gameOverReason = "You lost all your lives!";
        sounds.play('fail');
        stats.levelsFailed++;
        saveStats();
        refreshFavicon();
        return;
    }

    // ‚ùå Normal fail (retry same level)
    gameOver = true;
    gameOverReason = reason;
    sounds.play('fail');
    refreshFavicon();

    stats.levelsFailed++;
    saveStats();

        if (isCampaignMode) {
            hideCampaignTimer();
            campaignLevel = 1;
        }
    }

function getProgress() {
    const pct = initialBubbleCount > 0 ? (Math.max(0, initialBubbleCount - bubbles.length) / initialBubbleCount) * 100 : 100;
    return pct.toFixed(1) + "%";
}

function updateProgressBar() {

    let progressStr;

    if (loadedProgressOverride !== null) {
        progressStr = loadedProgressOverride;
    } else {
        progressStr = getProgress();
    }

    document.getElementById('progressBar').style.width = progressStr;
    document.getElementById('percentText').innerText = progressStr;
}

function update() {
    // ---- delta time (seconds) ----
const nowMs = performance.now();
const dt = (nowMs - lastTimeMs) / 1000;
lastTimeMs = nowMs;
panicPulseTime += 0.02; // speed of pulse (lower = slower)
const FADE_SPEED = 3; // lower = slower fade
const canvasEl = canvas; // already have it
if (isAiming) {
    aimGlowPulse += 0.15; // speed of glow pulse
} else {
    aimGlowPulse = 0;
}

// ---- CANVAS OUTER GLOW STATE ----
let glowSize = 0;
let glowColor = "rgba(0,0,0,0)";
// ‚ù§Ô∏è LOW LIVES PULSE (every second)
const inner = document.getElementById('livesInner');

if (
    inner &&
    !isPlaytesting &&
    !gameOver &&
    !gameWin &&
    lives > 0 &&
    lives < 4
) {
    const nowSec = Math.floor(performance.now() / 1000);

    if (lastLifePulseSecond !== nowSec) {
        inner.classList.remove('tick-pulse');
        void inner.offsetWidth; // force reflow
        inner.classList.add('tick-pulse');
        lastLifePulseSecond = nowSec;
    }
} else {
    lastLifePulseSecond = null;
}

// ü´Ä HEARTBEAT SFX (sync with pulse)
if (
    !isPlaytesting &&
    !isPaused &&
    !gameOver &&
    !gameWin &&
    lives > 0 &&
    lives < 4
) {
    const nowSec = Math.floor(performance.now() / 1000);

    if (lastHeartbeatSecond !== nowSec) {
        sounds.play('heartbeat');
        lastHeartbeatSecond = nowSec;
    }
} else {
    lastHeartbeatSecond = null;
}


// LEVEL FAILED ‚Üí solid red glow
if (gameOver) {
    glowSize = 45;
    glowColor = "rgba(255, 60, 60, 0.75)";
}

// LEVEL COMPLETE ‚Üí cyan glow
else if (gameWin) {
    glowSize = 45;
    glowColor = "rgba(0, 255, 204, 0.75)";
}

// PANIC MODE ‚Üí pulsing red glow
else if (panicFade > 0) {
    const pulse = (Math.sin(panicPulseTime) + 1) / 2;
    glowSize = 20 + pulse * 30;
    glowColor = `rgba(255, 80, 80, ${(0.25 + pulse * 0.25) * panicFade})`;
}

// Apply glow (always)
setCanvasGlow(glowSize, glowColor);

if (panicMode) {
    panicFade = Math.min(1, panicFade + FADE_SPEED);
} else {
    panicFade = Math.max(0, panicFade - FADE_SPEED);
}

if (isCampaignMode && !isPaused && !gameOver && !gameWin) {

        campaignTimer -= dt;


// use DISPLAYED time for logic
const secondsLeft = Math.ceil(campaignTimer);

if (secondsLeft <= -1) {
    triggerFail("You ran out of time!\n-1‚ù§Ô∏è");
    campaignLevel = 1;
}

        // üî• Ticking sound under 10 seconds
        if (secondsLeft <= 10 && secondsLeft > -1) {

            if (lastTickSecond !== secondsLeft) {
                sounds.play('tick');
const inner = document.getElementById('campaignTimerInner');
if (inner) {
    inner.classList.remove('tick-pulse');
    void inner.offsetWidth; // force reflow
    inner.classList.add('tick-pulse');
}


                lastTickSecond = secondsLeft;
            }

        } else {
            lastTickSecond = null;
        }
    }



    if (isPaused || isCustomMode) return;
    updatePanicState();
    if (!gameOver && !gameWin) {
        if (streakTimer > 0 && !streakFrozen) { 
            streakTimer--; 
            if (streakTimer <= 0) streakCount = 1; 
        }
        const streakPct = (streakTimer / STREAK_DURATION) * 100;
        document.getElementById('streakBar').style.width = (streakCount > 1 ? streakPct : 0) + "%";

        projectiles.forEach((p, i) => {
            particles.push({ x: p.x, y: p.y, vx: (Math.random()-0.5)*2, vy: (Math.random()-0.5)*2, life: 0.5, color: p.color, size: Math.random()*4+2 });
            p.x += p.dx; p.y += p.dy;
            if (p.x < RADIUS || p.x > canvas.width - RADIUS) { p.dx *= -1; sounds.play('bounce'); }
            if (p.y < RADIUS) { snapToGrid(p); projectiles.splice(i, 1); }
            else { for (let b of bubbles) { if (Math.hypot(p.x - b.x, p.y - b.y) < RADIUS * 1.5) { snapToGrid(p); projectiles.splice(i, 1); break; } } }
        });
        bubbles.forEach(b => { if (b.y > DEADLINE) triggerFail("You hit the red line!\n-1‚ù§Ô∏è"); });
        // üëª Ghost snap outline


    }
    particles.forEach((p, i) => { p.x += p.vx; p.y += p.vy; p.life -= 0.03; if (p.life <= 0) particles.splice(i, 1); });
    fallingBubbles.forEach((fb, i) => {
    fb.vx *= 0.98;          // damping (keeps it subtle)
    fb.x += fb.vx;
    fb.y += fb.vy;
    fb.rot += fb.rotSpeed;

    if (fb.y > canvas.height + 30) {

    // üß≤ DEBUG: absorb falling bubbles into ammo
    if (absorbFallingBubbles && !isPlaytesting) {
        ammo++;
        updateAmmo();
    }

    fallingBubbles.splice(i, 1);
}

});

    floatingScores.forEach((fs, i) => { fs.y -= 1; fs.life -= 0.01; if (fs.life <= 0) floatingScores.splice(i, 1); });
    confetti.forEach((c, i) => { c.x += c.vx; c.y += c.vy; c.vy += 0.2; c.life -= 0.01; if (c.life <= 0) confetti.splice(i, 1); });
}
function isCellOccupied(row, col, ignoreBubble) {
    return bubbles.some(b => b !== ignoreBubble && b.row === row && b.col === col);
}

function getSnapPreview(x, y) {
    let row = Math.max(0, Math.round((y - RADIUS) / ROW_HEIGHT));
    let offset = (row % 2 === 0) ? 0 : RADIUS;

    let col = Math.round((x - RADIUS - offset) / (RADIUS * 2));

    col = Math.max(0, Math.min(row % 2 === 0 ? 10 : 9, col));

    const coords = getGridCoords(row, col);

    const occupied = bubbles.some(b => b.row === row && b.col === col);

    return {
        row,
        col,
        x: coords.x,
        y: coords.y,
        occupied
    };
}

 function draw() {
    // ---- BACKGROUND ----
let bgColor = "#000000";

if (panicFade > 0) {
    const pulse = (Math.sin(panicPulseTime) + 1) / 2;
    const intensity = Math.floor(10 + pulse * 25 * panicFade);

    bgColor = `rgb(${intensity}, 0, 0)`;
}

ctx.fillStyle = bgColor;
ctx.fillRect(0, 0, canvas.width, canvas.height);


    ctx.strokeStyle = '#ff3333'; ctx.setLineDash([]);
    ctx.beginPath(); ctx.moveTo(0, DEADLINE); ctx.lineTo(canvas.width, DEADLINE); ctx.stroke(); ctx.setLineDash([]);
    bubbles.forEach(b => {
    // COLORLESS bubble = outline only
    if (!b.color) {
        ctx.strokeStyle = "#ffffff";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(b.x, b.y, RADIUS - 2, 0, Math.PI * 2);
        ctx.stroke();
        return;
    }
    ctx.strokeStyle = '#ff3333';
ctx.setLineDash([200, 200]);
ctx.beginPath();
ctx.moveTo(0, DEADLINE);
ctx.lineTo(canvas.width, DEADLINE);
ctx.stroke();
ctx.setLineDash([]);

// ===============================
// üëª SNAP GHOST (UNDER BUBBLES)
// ===============================
if (dragBubblesEnabled && draggedBubble && snapPreview) {
    ctx.save();

    ctx.lineWidth = 3;
    ctx.setLineDash([6, 6]);

ctx.strokeStyle =
    snapIsValidMatch
        ? "rgba(0, 255, 120, 0.9)"          // üü¢ will pop
        : snapWillFall
            ? "rgba(160, 160, 160, 0.8)"   // ü©∂ will fall
            : snapPreview.occupied
                ? "rgba(255, 80, 80, 0.9)" // üî¥ blocked
                : "rgba(255, 255, 255, 0.7)"; // ‚ö™ normal

    ctx.beginPath();
    ctx.arc(snapPreview.x, snapPreview.y, RADIUS, 0, Math.PI * 2);
    ctx.stroke();

    ctx.globalAlpha = 0.22;
    ctx.fillStyle = draggedBubble.color || "#ffffff";
    ctx.beginPath();
    ctx.arc(snapPreview.x, snapPreview.y, RADIUS, 0, Math.PI * 2);
    ctx.fill();

    ctx.restore();
}

// ---- CANVAS GLOW ----
if (panicMode) {
    const glow = (Math.sin(panicPulseTime) + 1) / 2;
    const glowStrength = 6 + glow * 10;

    ctx.save();
    ctx.strokeStyle = `rgba(255, 80, 80, ${0.15 + glow * 0.2})`;
    ctx.lineWidth = 6;
    ctx.shadowBlur = glowStrength;
    ctx.shadowColor = "#ff3333";

    ctx.strokeRect(
        3,
        3,
        canvas.width - 6,
        canvas.height - 6
    );
    ctx.restore();
}

    // Normal colored bubble
    ctx.fillStyle = b.color;
    ctx.beginPath();
    ctx.arc(b.x, b.y, RADIUS - 2, 0, Math.PI * 2);
    ctx.fill();

    // Colorblind emoji overlay (only for colored bubbles)
    if (colorblindMode) {
        ctx.fillStyle = "black";
        ctx.font = "16px Storopia";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(COLOR_EMOJIS[b.color] || '‚ùî', b.x, b.y);
    }
});


    if (!isCustomMode) {
        ctx.save();
        fallingBubbles.forEach(fb => { ctx.globalAlpha = 0.5; ctx.fillStyle = fb.color; ctx.beginPath(); ctx.arc(fb.x, fb.y, RADIUS - 2, 0, Math.PI * 2); ctx.fill(); });
        particles.forEach(p => { ctx.globalAlpha = p.life; ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2); ctx.fill(); });
        // ---- Floating score text ----
        ctx.save();
        floatingScores.forEach(fs => {
            ctx.globalAlpha = fs.life;
            ctx.fillStyle = "#00ffcc";
            ctx.font = "bold 20px Storopia";
            ctx.textAlign = "center";
            ctx.fillText(fs.text, fs.x, fs.y);
        });
        ctx.restore();
        confetti.forEach(c => { ctx.globalAlpha = c.life; ctx.fillStyle = c.color; ctx.fillRect(c.x, c.y, 5, 5); });
        ctx.restore();
        projectiles.forEach(p => {
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, RADIUS - 2, 0, Math.PI * 2);
            ctx.fill();
        });

        drawAimVisualizer(); // ‚úÖ TOP LAYER ‚Äî now visible

        if (ammo > 0) {

            // ---- CURRENT BALL ----
const cx = canvas.width / 2;
const cy = canvas.height - 80;
if (ammo => -1) {
    ctx.save();

    ctx.font = "bold 14px Storopia";
    ctx.textAlign = "center";
    ctx.textBaseline = "top";

    const counterX = canvas.width / 2 + 60;
    const counterY = canvas.height - 80 + RADIUS + 8;

     // üî¥ red under 10, üü° normal otherwise
    ctx.fillStyle = ammo < 10 ? "#ff4444" : "#ffcc00";
    if (ammo < 10) {
    ctx.shadowBlur = 10;
    ctx.shadowColor = "#ff4444";
}
    ctx.fillText(ammo.toString(), counterX, counterY);

    ctx.restore();
}
// üåü Glow when aiming
if (isAiming) {
    const pulse = (Math.sin(aimGlowPulse) + 1) / 2;

    ctx.save();
    ctx.shadowBlur = 20 + pulse * 15;
    ctx.shadowColor = currentBall || "#ffffff";
    ctx.fillStyle = currentBall || "#ffffff";
    ctx.beginPath();
    ctx.arc(cx, cy, RADIUS, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
} else {
    ctx.fillStyle = currentBall;
    ctx.beginPath();
    ctx.arc(cx, cy, RADIUS, 0, Math.PI * 2);
    ctx.fill();
}
if (isAiming) {
    ctx.save();
    ctx.strokeStyle = currentBall || "#ffffff";
    ctx.lineWidth = 3;
    ctx.globalAlpha = 0.6;
    ctx.beginPath();
    ctx.arc(cx, cy, RADIUS + 4, 0, Math.PI * 2);
    ctx.stroke();
    ctx.restore();
}


            if (colorblindMode) {
                ctx.fillStyle = "black";
                ctx.font = "20px Storopia";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText(
                    COLOR_EMOJIS[currentBall] || '‚ùî',
                    canvas.width / 2,
                    canvas.height - 80
                );
            }

            // ---- NEXT BALL ----
            if (ammo > 1) {
                ctx.fillStyle = nextBall;
                ctx.beginPath();
                ctx.arc(canvas.width / 2 + 60, canvas.height - 80, RADIUS * 0.7, 0, Math.PI * 2);
                ctx.fill();
		
                if (colorblindMode) {
                    ctx.fillStyle = "black";
                    ctx.font = "16px Storopia";
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    ctx.fillText(
                        COLOR_EMOJIS[nextBall] || '‚ùî',
                        canvas.width / 2 + 60,
                        canvas.height - 80
                    );
                    // ---- NEXT BUBBLE COUNTER ----

                }
            }
        }

        if (isPaused) {
            ctx.fillStyle = "rgba(0,0,0,0.6)"; ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = "#ffcc00"; ctx.textAlign = "center"; ctx.font = "bold 40px Storopia";
            ctx.fillText("GAME PAUSED", 220, 310);

            ctx.font = "16px Storopia";
            ctx.fillText("Click \"RESUME\" to unpause the game", canvas.width / 2, 370);
        }
        if (gameOver || gameWin) {
    ctx.fillStyle = "rgba(0,0,0,0.85)";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.textAlign = "center";

    // --- CAMPAIGN FINISHED SCREEN ---
    if (campaignFinished) {
        ctx.fillStyle = "#00ffcc";

        ctx.font = "bold 36px Storopia";
        ctx.fillText("CONGRATULATIONS!", canvas.width / 2, 250);

        ctx.font = "22px Storopia";
        ctx.fillText("You've beaten Campaign Mode!", canvas.width / 2, 300);

        ctx.fillStyle = "#FFFFFF";
        ctx.font = "16px Storopia";
        ctx.fillText("Double click to advance to Level 21 in Puzzle Mode", canvas.width / 2, 340);
    }

    // --- PERFECT WIN SCREEN ---
    else if (!gameOver && lastClearWasPerfect) {
        ctx.fillStyle = "#FFD700";
        ctx.shadowColor = "#FFD700";
        ctx.shadowBlur = 12;

        ctx.font = "bold 40px Storopia";
        ctx.fillText("PERFECT!", canvas.width / 2, 260);

        ctx.shadowBlur = 0;

        ctx.font = "bold 20px Storopia";
        ctx.fillText(isPlaytesting ? "" : "+1,000 SCORE  +150 BUBBLES  +10‚ù§Ô∏è", canvas.width / 2, 295);

        ctx.fillStyle = "#FFFFFF";
        ctx.font = "16px Storopia";
        ctx.fillText("Click to continue", canvas.width / 2, 330);
    }

    // --- NORMAL WIN/FAIL SCREEN ---
    else {
        ctx.fillStyle = gameOver ? "#ff5555" : "#00ffcc";
        ctx.font = "bold 34px Storopia";
        const endText =
    gameOver
        ? (lives <= 0 ? "GAME OVER!" : "LEVEL FAILED!")
        : "LEVEL COMPLETE!";

ctx.fillText(endText, canvas.width / 2, 280);

		    // üéÅ Show bubble reward ONLY on win
    if (gameWin && !gameOver) {
        ctx.fillStyle = "#ffcc00";
        ctx.font = "bold 22px Storopia";
        ctx.fillText(isPlaytesting ? "" : "+50 BUBBLES! +1‚ù§Ô∏è", canvas.width / 2, 315);
    }
        if (gameOver && gameOverReason) {
            ctx.fillStyle = "#FF0000"
			ctx.font = "20px Storopia";
            ctx.fillText(gameOverReason, canvas.width / 2, 350);
        }
		
        ctx.fillStyle = "#FFFFFF";
        ctx.font = "16px Storopia";
        ctx.fillText(lives <= 0 ? "Click to exit to the main menu" : "Click to continue", canvas.width / 2, 420); // lol
        if (gameWin) {
    ctx.save();
    confetti.forEach(c => {
        ctx.globalAlpha = c.life;
        ctx.fillStyle = c.color;
        ctx.fillRect(c.x, c.y, 5, 5);
    });
    ctx.restore();
    }
    // ===============================
// ü´ß DRAGGED BUBBLE (TOP LAYER)
// ===============================
if (dragBubblesEnabled && draggedBubble) {
    ctx.save();

    ctx.globalAlpha = 0.9;
    ctx.strokeStyle = "#ffffff";
    ctx.lineWidth = 2;
    ctx.fillStyle = draggedBubble.color || "#ffffff";

    ctx.beginPath();
    ctx.arc(mouseX, mouseY, RADIUS, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();

    ctx.restore();
    }      
  }
 }

// ‚úÖ Keep these UI updates OUTSIDE the win-screen branches (and outside draw braces issues)
document.getElementById('scoreDisplay').innerText =
    `Score: ${fmt(score)}`;

const timerSpan = document.getElementById('campaignTimerDisplay');
const inner = document.getElementById('campaignTimerInner');
if (isCampaignMode) {
    const t = Math.ceil(campaignTimer);
    const minutes = Math.floor(t / 60);
    const seconds = t % 60;



if (isCampaignMode && timerSpan && inner) {
    const t = Math.ceil(campaignTimer);
    const minutes = Math.floor(t / 60);
    const seconds = t % 60;

    timerSpan.style.display = "inline";
    inner.innerText = `${minutes}:${seconds.toString().padStart(2, '0')}`;

    if (t <= 20) {
        inner.style.color = "#ff3333";
    } else if (t <= 60) {
        inner.style.color = "#ffcc00";
    } else {
        inner.style.color = "#66ff00";
    }
} else if (timerSpan) {
    timerSpan.style.display = "none";
}
}

// ---- Level Display Update ----
let levelText;
if (isCampaignMode) levelText = `${campaignLevel}/${CAMPAIGN_TOTAL_LEVELS}`;
else if (isPlaytesting && customLevelName && customAuthorName) levelText = `Custom (${customLevelName} by ${customAuthorName})`;
else if (mode === 'custom') levelText = "Custom Editor";
else levelText = level;

document.getElementById('levelDisplay').innerText = `Level: ${levelText}`;
document.getElementById('streakDisplay').innerText =
    `Streak: x${fmt(streakCount)} | Perfect streak: x${fmt(perfectStreak)}`;
	
	if (visualiseBubbleColour) {

    const hovered = getHoveredBubble();
    if (hovered) {
        showHexOverlay(
            hovered.color || "COLORLESS",
            hovered.color,
            mouseX + canvas.getBoundingClientRect().left,
            mouseY + canvas.getBoundingClientRect().top
        );
        return;
    }

    if (isHoveringCurrentBubble()) {
        showHexOverlay(
            currentBall || "COLORLESS",
            currentBall,
            mouseX + canvas.getBoundingClientRect().left,
            mouseY + canvas.getBoundingClientRect().top
        );
        return;
    }

    if (isHoveringNextBubble()) {
        showHexOverlay(
            nextBall || "COLORLESS",
            nextBall,
            mouseX + canvas.getBoundingClientRect().left,
            mouseY + canvas.getBoundingClientRect().top
        );
        return;
    }

    hideHexOverlay();
}
// ===============================
// üß≤ DRAG MODE CURSOR EMOJI (FIXED CENTERING)
// ===============================
if (dragBubblesEnabled) {
    ctx.save();

    const size = draggedBubble ? 28 : 22;
    ctx.font = `${size}px Storopia`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    ctx.globalAlpha = draggedBubble ? 0.95 : 0.6;

    ctx.fillText(
        DRAG_EMOJI,
        mouseX,
        mouseY
    );

    ctx.restore();
}

}}
function gameLoop() { if (gameRunning) { update(); draw(); animationId = requestAnimationFrame(gameLoop); } }

function initializeAmmo(type, savedAmmo = null) {

        switch (type) {

            case "puzzleNew":
                ammo = Math.floor(Math.random() * 51) + 50;
                break;

            case "puzzleLoad":
                ammo = savedAmmo ?? 40;
                break;

            case "customPlaytest":
                ammo = parseInt(document.getElementById('customAmmoInput').value) || 40;
                break;

            case "customLoad":
                ammo = savedAmmo ?? 40;
                break;
        }

        updateAmmo();
    }
    function startPuzzleMode() {
        lives = DEFAULT_LIVES;
        updateLivesUI();
        stats.puzzlePlays++;
        saveStats();
        setBrowserTitle("üß© SK's Bubble Shooter ‚Äî Puzzle Mode");
        isCampaignMode = false;   // ‚úÖ force campaign off
        campaignLevel = 1;
        campaignTimer = 0;
        lastTickSecond = null;
        hideCampaignTimer();
        startMode('puzzle');
    }
function hideCampaignTimer() {
    const timerSpan = document.getElementById('campaignTimerDisplay');
    if (timerSpan) {
        timerSpan.style.display = "none";
    }
}

function startMode(m, isLoad = false, isNextLevel = false) {
    mode = m; 
    // If manually starting puzzle mode from menu,
    // reset campaign ONLY if we're not already in campaign
    if (m === 'puzzle' && !isNextLevel && !isCampaignMode) {
        campaignLevel = 1;
        campaignTimer = 0;
        lastTickSecond = null;
    }
    gameRunning = true; gameOver = false; gameWin = false; isPaused = false; isCustomMode = false; isPlaytesting = false;
    lastClearWasPerfect = false;
    if (!isLoad) {

    if (!isNextLevel) {
        score = 0;
    }

    if (isCampaignMode) {
        level = campaignLevel;
    } else if (!isNextLevel) {
        level = 1;
    }

    if (!isNextLevel) {
    initializeAmmo("puzzleNew");
}}


    if (!isLoad) {bubbles = [];} fallingBubbles = []; projectiles = []; particles = []; confetti = [];
    document.getElementById('mainMenu').style.display = 'none';
    document.getElementById('customUI').style.display = 'none';
    document.getElementById('gameUI').style.display = 'block';
	// force valid mouse position so aim line can render immediately
mouseX = canvas.width / 2;
mouseY = canvas.height - 200;

    document.getElementById('mobileControls').style.display = 'flex';
    document.getElementById('progressContainer').style.display = 'block';
    document.getElementById('streakContainer').style.display = 'block';
    document.getElementById('percentText').style.display = 'inline-block';
    canvas.style.display = 'block';
    
    // Generate new level layout
    if (!isLoad) {
    levelPattern = Math.floor(Math.random() * 100);
    for (let r = 0; r < Math.min(5 + Math.floor(level/2), 8); r++) {
        createRow(r);
    }
}
    if (isLoad) {
        // ammo will be set inside loadGame()
    }

    initialBubbleCount = bubbles.length; 
    updateProgressBar();
    updateLivesUI(); 
    updateAmmo();
    
    if (isNextLevel && mode === 'puzzle' && autosaveEnabled && !isCampaignMode && !suppressAutosaveOnce) {
    saveGame(true);
}
suppressAutosaveOnce = false; // always clear after startMode



    if (animationId) cancelAnimationFrame(animationId);
    gameLoop();
    }
    refreshFavicon();

function enterCustomEditor() {
    stats.customPlays++;
    saveStats();
    setBrowserTitle("üõ†Ô∏è SK's Bubble Shooter ‚Äî Level Editor");
    mode = 'custom'; isCustomMode = true; gameRunning = true; gameOver = false; gameWin = false; isPlaytesting = false; isCampaignMode = false;
    hideCampaignTimer();
    document.getElementById('mainMenu').style.display = 'none';
    document.getElementById('customUI').style.display = 'block';
	// force valid mouse position so aim line can render immediately
mouseX = canvas.width / 2;
mouseY = canvas.height - 200;

    document.getElementById('gameUI').style.display = 'none';
    document.getElementById('mobileControls').style.display = 'flex';
    document.getElementById('progressContainer').style.display = 'none';
document.getElementById('percentText').style.display = 'none';
    canvas.style.display = 'block';
    updatePaletteUI();
    if (animationId) cancelAnimationFrame(animationId);
    gameLoop();
}

function hasAtLeastOneConnection(bubble) {
    const r = bubble.row;
    const c = bubble.col;

    const dirs = (r % 2 === 0)
        ? [[-1,-1],[-1,0],[0,-1],[0,1],[1,-1],[1,0]]
        : [[-1,0],[-1,1],[0,-1],[0,1],[1,0],[1,1]];

    return dirs.some(d =>
        bubbles.some(b =>
            b.row === r + d[0] &&
            b.col === c + d[1]
        )
    );
}
    function hasReachableColoredBubble() {
    const visited = new Set();
    const queue = [];

    // Start from all TOP ROW colored bubbles
    bubbles.forEach(b => {
        if (b.row === 0 && b.color) {
            queue.push(b);
            visited.add(`${b.row},${b.col}`);
        }
    });

    while (queue.length > 0) {
        const cur = queue.shift();

        // If we find ANY colored bubble, level is playable
        if (cur.color) return true;

        const dirs = (cur.row % 2 === 0)
            ? [[-1,-1],[-1,0],[0,-1],[0,1],[1,-1],[1,0]]
            : [[-1,0],[-1,1],[0,-1],[0,1],[1,0],[1,1]];

        dirs.forEach(([dr, dc]) => {
            const nr = cur.row + dr;
            const nc = cur.col + dc;
            const key = `${nr},${nc}`;

            if (visited.has(key)) return;

            const nb = bubbles.find(b => b.row === nr && b.col === nc);
            if (!nb) return;

            // ‚ùó BLOCK traversal through colourless bubbles
            if (!nb.color) return;

            visited.add(key);
            queue.push(nb);
        });
    }

    return false;
}
function startFromCustom() {
    if (bubbles.length === 0) {
        alert("Add some bubbles in the canvas first!");
        return;
    }

    if (bubbles.length < 3) {
        alert("Add at least 3 bubbles on to the canvas.");
        return;
    }

    // üö´ NEW CHECK ‚Äî colorless on top row
    const hasColorlessTopRow = bubbles.some(b => b.row === 0 && !b.color);
    if (hasColorlessTopRow) {
        alert("Don't put the colourless bubbles on the top row.");
        return;
    }

    // üö® existing floating-bubble check
    const hasFloating = bubbles.some(b => !hasAtLeastOneConnection(b));
    if (hasFloating) {
        alert("Connect one of the floating bubbles to another bubble.");
        return;
    }
        // üö´ Block inaccessible layouts (sealed by colourless bubbles)
if (!hasReachableColoredBubble()) {
    alert("This level has no reachable bubbles. Remove or reposition colourless bubbles.");
    return;
}
setBrowserTitle("‚ñ∂Ô∏è SK's Bubble Shooter ‚Äî Playtesting");
    customLevelSnapshot = JSON.parse(JSON.stringify(bubbles));
    isCustomMode = false;
    isPlaytesting = true;
    updateLivesUI();
    gameOver = false;
    gameWin = false;

    score = 0;
    streakCount = 1;
    streakTimer = 0;

    document.getElementById('customUI').style.display = 'none';
    document.getElementById('gameUI').style.display = 'block';
    document.getElementById('streakContainer').style.display = 'block';

    // ‚úÖ SHOW PROGRESS BAR
    document.getElementById('progressContainer').style.display = 'block';
    document.getElementById('percentText').style.display = 'inline-block';

    initializeAmmo("customPlaytest");

    initialBubbleCount = bubbles.length;
    updateProgressBar();
    updateAmmo();
}
    
function hasParentAbove(r, c) {

    if (r === 0) return true;

    const parents = (r % 2 === 0)
        ? [[r-1, c-1], [r-1, c]]
        : [[r-1, c], [r-1, c+1]];

    return parents.some(([pr, pc]) =>
        bubbles.some(b => b.row === pr && b.col === pc)
    );
}
function drawAimVisualizer() {

        if (!aimEnabled || isPaused || gameOver || gameWin || isCustomMode || projectiles.length > 0) return;

        if (
            mouseX < 0 ||
            mouseX > canvas.width ||
            mouseY < 0 ||
            mouseY > DEADLINE
        ) return;

        const startX = canvas.width / 2;
        const startY = canvas.height - 80;

        let simX = startX;
        let simY = startY;
        let dx = Math.cos(angle) * 12;
        let dy = Math.sin(angle) * 12;

        ctx.save();
        ctx.strokeStyle = currentBall;
        ctx.globalAlpha = 0.6;
        ctx.setLineDash([9999, 9999]);
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(simX, simY);

        for (let i = 0; i < 500; i++) {

            simX += dx;
            simY += dy;

            // wall bounce
            if (simX < RADIUS || simX > canvas.width - RADIUS) {
                dx *= -1;
            }

            // hit ceiling
            if (simY < RADIUS) {
                ctx.lineTo(simX, simY);
                break;
            }

            // üî• BUBBLE COLLISION CHECK (same as projectile)
            for (let b of bubbles) {
                if (Math.hypot(simX - b.x, simY - b.y) < RADIUS * 1.5) {
                    ctx.lineTo(simX, simY);
                    ctx.stroke();
                    ctx.restore();
                    return; // stop drawing here
                }
            }

            ctx.lineTo(simX, simY);
        }

        ctx.stroke();
        ctx.setLineDash([]);
        ctx.restore();
    }

function shouldPlaceBubble(r, c) {

    if (r === 0) return true;

    // First rule: must be attached to something above
    if (!hasParentAbove(r, c)) return false;

    const density = 0.55 + (Math.random() * 0.35);
    const centerBias = Math.abs(c - 5) < (Math.random() * 4 + 2);

    return Math.random() < density && centerBias;
}
    
function createRow(r) {
    const patternType = levelPattern; // decided per level

    for (let c = 0; c < (r % 2 === 0 ? 11 : 10); c++) {
        if (!shouldPlaceBubble(r, c)) continue;

        let color;

        // ‚úÖ Random colourless bubbles, but NEVER on top row
        if (r > 0 && Math.random() < COLORLESS_CHANCE) {
            color = null; // colourless / stone
        } else {
            switch (patternType) {
                case 0:  color = ALL_COLORS[(r + c) % ALL_COLORS.length]; break;
                case 1:  color = ALL_COLORS[c % ALL_COLORS.length]; break;
                case 2:  color = ALL_COLORS[r % ALL_COLORS.length]; break;
                case 3:  color = ALL_COLORS[Math.abs(c - 5) % ALL_COLORS.length]; break;
                case 4:  color = ALL_COLORS[Math.floor(Math.abs(c - 5) / 2) % ALL_COLORS.length]; break;
                case 5:  color = ALL_COLORS[(r * c) % ALL_COLORS.length]; break;
                case 6:  color = ALL_COLORS[(r * r + c) % ALL_COLORS.length]; break;
                case 7:  color = ALL_COLORS[(c * c + r) % ALL_COLORS.length]; break;
                case 8:  color = ALL_COLORS[(r + c * c) % ALL_COLORS.length]; break;
                case 9:  color = ALL_COLORS[(r * r + c * c) % ALL_COLORS.length]; break;

                case 10: color = ALL_COLORS[Math.floor(c / 2) % ALL_COLORS.length]; break;
                case 11: color = ALL_COLORS[Math.floor(r / 2) % ALL_COLORS.length]; break;
                case 12: color = ALL_COLORS[(Math.floor(c / 2) + r) % ALL_COLORS.length]; break;
                case 13: color = ALL_COLORS[(Math.floor(r / 2) + c) % ALL_COLORS.length]; break;
                case 14: color = ALL_COLORS[(r % 2 === 0 ? c : c + 3) % ALL_COLORS.length]; break;

                case 15: color = ALL_COLORS[(r % 3 + c % 3) % ALL_COLORS.length]; break;
                case 16: color = ALL_COLORS[(r % 4 + c % 2) % ALL_COLORS.length]; break;
                case 17: color = ALL_COLORS[(r % 5 + c % 3) % ALL_COLORS.length]; break;
                case 18: color = ALL_COLORS[(r % 2 ? c % 5 : c % 3) % ALL_COLORS.length]; break;
                case 19: color = ALL_COLORS[(r % 7 + c % 4) % ALL_COLORS.length]; break;

                case 20: color = ALL_COLORS[((Math.sin(r + c) * 10) | 0) % ALL_COLORS.length]; break;
                case 21: color = ALL_COLORS[((Math.cos(r * c) * 10) | 0) % ALL_COLORS.length]; break;
                case 22: color = ALL_COLORS[(Math.abs(r - c)) % ALL_COLORS.length]; break;
                case 23: color = ALL_COLORS[(Math.abs(r - 5) + Math.abs(c - 5)) % ALL_COLORS.length]; break;
                case 24: color = ALL_COLORS[(Math.max(r, c)) % ALL_COLORS.length]; break;

                case 25: color = ALL_COLORS[(r ^ c) % ALL_COLORS.length]; break;
                case 26: color = ALL_COLORS[((r << 1) + c) % ALL_COLORS.length]; break;
                case 27: color = ALL_COLORS[((c << 1) + r) % ALL_COLORS.length]; break;
                case 28: color = ALL_COLORS[((r & c) + c) % ALL_COLORS.length]; break;
                case 29: color = ALL_COLORS[((r | c) + r) % ALL_COLORS.length]; break;

                case 30: color = ALL_COLORS[Math.floor(Math.sqrt(r * c + 1)) % ALL_COLORS.length]; break;
                case 31: color = ALL_COLORS[Math.floor((r * c) / 2) % ALL_COLORS.length]; break;
                case 32: color = ALL_COLORS[Math.floor(((r + 1) * (c + 1)) / 3) % ALL_COLORS.length]; break;
                case 33: color = ALL_COLORS[Math.floor((r * r * c) / 7) % ALL_COLORS.length]; break;
                case 34: color = ALL_COLORS[Math.floor((c * c * r) / 7) % ALL_COLORS.length]; break;

                case 35: color = ALL_COLORS[(r % 2 === 0 ? r + c : r * c) % ALL_COLORS.length]; break;
                case 36: color = ALL_COLORS[(c % 2 === 0 ? r + c : r * c) % ALL_COLORS.length]; break;
                case 37: color = ALL_COLORS[((r + c) % 2 === 0 ? r : c) % ALL_COLORS.length]; break;
                case 38: color = ALL_COLORS[((r * c) % 2 === 0 ? r + c : r) % ALL_COLORS.length]; break;
                case 39: color = ALL_COLORS[((r + c) % 3 === 0 ? r * c : r + c) % ALL_COLORS.length]; break;

                case 40: color = ALL_COLORS[(r * 3 + c * 5) % ALL_COLORS.length]; break;
                case 41: color = ALL_COLORS[(r * 5 + c * 3) % ALL_COLORS.length]; break;
                case 42: color = ALL_COLORS[(r * 7 + c * 11) % ALL_COLORS.length]; break;
                case 43: color = ALL_COLORS[(r * 11 + c * 7) % ALL_COLORS.length]; break;
                case 44: color = ALL_COLORS[(r * 13 + c * 17) % ALL_COLORS.length]; break;

                case 45: color = ALL_COLORS[(Math.abs(5 - r) * Math.abs(5 - c)) % ALL_COLORS.length]; break;
                case 46: color = ALL_COLORS[(Math.abs(5 - r) + Math.abs(5 - c)) % ALL_COLORS.length]; break;
                case 47: color = ALL_COLORS[(Math.abs(5 - r) - Math.abs(5 - c) + 50) % ALL_COLORS.length]; break;
                case 48: color = ALL_COLORS[(r * r - c * c + 100) % ALL_COLORS.length]; break;
                case 49: color = ALL_COLORS[Math.floor(Math.random() * ALL_COLORS.length)]; break;
                /* =====================
   NEW PATTERNS 50‚Äì99
   ===================== */

case 50: color = ALL_COLORS[(r + c * 2) % ALL_COLORS.length]; break;
case 51: color = ALL_COLORS[(c + r * 2) % ALL_COLORS.length]; break;
case 52: color = ALL_COLORS[(r * 2 + c * 3) % ALL_COLORS.length]; break;
case 53: color = ALL_COLORS[(r * 3 + c * 2) % ALL_COLORS.length]; break;
case 54: color = ALL_COLORS[(r * 4 + c) % ALL_COLORS.length]; break;

case 55: color = ALL_COLORS[(Math.floor(c / 3) + r) % ALL_COLORS.length]; break;
case 56: color = ALL_COLORS[(Math.floor(r / 3) + c) % ALL_COLORS.length]; break;
case 57: color = ALL_COLORS[(Math.floor((r + c) / 2)) % ALL_COLORS.length]; break;
case 58: color = ALL_COLORS[(Math.floor((r * c) / 3)) % ALL_COLORS.length]; break;
case 59: color = ALL_COLORS[(Math.floor((r * r + c) / 4)) % ALL_COLORS.length]; break;

case 60: color = ALL_COLORS[(Math.abs((r % 6) - (c % 6))) % ALL_COLORS.length]; break;
case 61: color = ALL_COLORS[(Math.abs((r % 4) - (c % 4))) % ALL_COLORS.length]; break;
case 62: color = ALL_COLORS[(Math.abs((r % 8) - (c % 5))) % ALL_COLORS.length]; break;
case 63: color = ALL_COLORS[(Math.abs(r - c) * 2) % ALL_COLORS.length]; break;
case 64: color = ALL_COLORS[(Math.abs(r - c + 3)) % ALL_COLORS.length]; break;

case 65: color = ALL_COLORS[((r + c) % 4 === 0 ? r : c) % ALL_COLORS.length]; break;
case 66: color = ALL_COLORS[((r + c) % 3 === 0 ? r + c : r) % ALL_COLORS.length]; break;
case 67: color = ALL_COLORS[((r * c) % 3 === 0 ? r : c) % ALL_COLORS.length]; break;
case 68: color = ALL_COLORS[((r * c) % 5 === 0 ? r + c : c) % ALL_COLORS.length]; break;
case 69: color = ALL_COLORS[((r + c) % 5 === 0 ? r * c : r) % ALL_COLORS.length]; break;

case 70: color = ALL_COLORS[(Math.floor(Math.sin(r) * 10 + c)) % ALL_COLORS.length]; break;
case 71: color = ALL_COLORS[(Math.floor(Math.cos(c) * 10 + r)) % ALL_COLORS.length]; break;
case 72: color = ALL_COLORS[(Math.floor(Math.sin(r + c) * 8)) % ALL_COLORS.length]; break;
case 73: color = ALL_COLORS[(Math.floor(Math.cos(r - c) * 8)) % ALL_COLORS.length]; break;
case 74: color = ALL_COLORS[(Math.floor(Math.sin(r * c) * 6)) % ALL_COLORS.length]; break;

case 75: color = ALL_COLORS[(r * r + c) % ALL_COLORS.length]; break;
case 76: color = ALL_COLORS[(c * c + r) % ALL_COLORS.length]; break;
case 77: color = ALL_COLORS[(r * r + c * c) % ALL_COLORS.length]; break;
case 78: color = ALL_COLORS[(r * r - c * c + 200) % ALL_COLORS.length]; break;
case 79: color = ALL_COLORS[(r * c + r + c) % ALL_COLORS.length]; break;

case 80: color = ALL_COLORS[((r + 1) * (c + 1)) % ALL_COLORS.length]; break;
case 81: color = ALL_COLORS[((r + 2) * (c + 3)) % ALL_COLORS.length]; break;
case 82: color = ALL_COLORS[((r + 3) * (c + 5)) % ALL_COLORS.length]; break;
case 83: color = ALL_COLORS[((r + 5) * (c + 2)) % ALL_COLORS.length]; break;
case 84: color = ALL_COLORS[((r + 7) * (c + 3)) % ALL_COLORS.length]; break;

case 85: color = ALL_COLORS[(Math.min(r, c)) % ALL_COLORS.length]; break;
case 86: color = ALL_COLORS[(Math.max(r, c)) % ALL_COLORS.length]; break;
case 87: color = ALL_COLORS[(Math.min(r + c, 10)) % ALL_COLORS.length]; break;
case 88: color = ALL_COLORS[(Math.max(r - c + 10, 0)) % ALL_COLORS.length]; break;
case 89: color = ALL_COLORS[(Math.abs(r * 2 - c)) % ALL_COLORS.length]; break;

case 90: color = ALL_COLORS[(r % 2 === 0 ? c * 2 : c) % ALL_COLORS.length]; break;
case 91: color = ALL_COLORS[(c % 2 === 0 ? r * 2 : r) % ALL_COLORS.length]; break;
case 92: color = ALL_COLORS[((r % 3 === 0) ? r + c : c) % ALL_COLORS.length]; break;
case 93: color = ALL_COLORS[((c % 3 === 0) ? r + c : r) % ALL_COLORS.length]; break;
case 94: color = ALL_COLORS[((r + c) % 2 ? r * 2 : c * 2) % ALL_COLORS.length]; break;

case 95: color = ALL_COLORS[(Math.floor((r + c) / 3) * 2) % ALL_COLORS.length]; break;
case 96: color = ALL_COLORS[(Math.floor((r * c) / 4) * 3) % ALL_COLORS.length]; break;
case 97: color = ALL_COLORS[(Math.floor((r * r + c) / 5)) % ALL_COLORS.length]; break;
case 98: color = ALL_COLORS[(Math.floor((c * c + r) / 5)) % ALL_COLORS.length]; break;
case 99: color = ALL_COLORS[(r + c + Math.floor(Math.random() * 3)) % ALL_COLORS.length]; break;

                default: color = ALL_COLORS[Math.floor(Math.random() * ALL_COLORS.length)]; break;
            }
        }

        let co = getGridCoords(r, c);

        // ‚úÖ Store color ONLY if it exists (keeps ‚Äúmissing color property‚Äù style)
        const bubble = { x: co.x, y: co.y, row: r, col: c };
        if (color) bubble.color = color;

        bubbles.push(bubble);
    }
}
function getGridCoords(r, c) {
    const off = (r % 2 === 0) ? 0 : RADIUS;
    return {
        x: RADIUS + (c * RADIUS * 2) + off,
        y: RADIUS + (r * ROW_HEIGHT)
    };
}

function findMatches(s) {
    // Colorless bubbles never match
    if (!s) return [s];

    let m = [s];
    let seen = new Set([`${s.row},${s.col}`]);
    let q = [s];

    while (q.length > 0) {
        let cur = q.shift();
        let ds = (cur.row % 2 === 0)
            ? [[-1,-1],[-1,0],[0,-1],[0,1],[1,-1],[1,0]]
            : [[-1,0],[-1,1],[0,-1],[0,1],[1,0],[1,1]];

        ds.forEach(d => {
            let nb = bubbles.find(o => o.row === cur.row + d[0] && o.col === cur.col + d[1]);
            if (!nb) return;
            const key = `${nb.row},${nb.col}`;
            if (seen.has(key)) return;
            if (nb.color !== s.color) return;

            seen.add(key);
            m.push(nb);
            q.push(nb);
        });
    }
    return m;
}
function dropFloatingBubbles() {
    const connected = new Set();
    const queue = bubbles.filter(b => b.row === 0);

    queue.forEach(b => connected.add(`${b.row},${b.col}`));

    let i = 0;
    while (i < queue.length) {
        const curr = queue[i++];
        const dirs = (curr.row % 2 === 0)
            ? [[-1,-1],[-1,0],[0,-1],[0,1],[1,-1],[1,0]]
            : [[-1,0],[-1,1],[0,-1],[0,1],[1,0],[1,1]];

        dirs.forEach(([dr, dc]) => {
            const nb = bubbles.find(b => b.row === curr.row + dr && b.col === curr.col + dc);
            if (!nb) return;

            const key = `${nb.row},${nb.col}`;
            if (connected.has(key)) return;

            connected.add(key);
            queue.push(nb);
        });
    }

    const remaining = [];
    let droppedCount = 0;

    bubbles.forEach(b => {
        if (connected.has(`${b.row},${b.col}`)) {
            remaining.push(b);
        } else {
            // ‚úÖ send to falling animation
            fallingBubbles.push({
    x: b.x,
    y: b.y,
    vx: (Math.random() - 0.5) * 2.5, // side wobble
    vy: 3 + Math.random() * 2,
    rot: Math.random() * Math.PI * 2,
    rotSpeed: (Math.random() - 0.5) * 0.1,
    color: b.color
});

            droppedCount++;
        }
    });

    if (droppedCount > 0) {
        sounds.play('fall');
        stats.bubblesDropped += droppedCount;
        saveStats();
    }

    bubbles = remaining;
}
	
function updateAmmo(rollNext = false) {
    // Pool = colors that exist on board (ignore colorless)
    const pool = bubbles.length > 0
        ? Array.from(new Set(bubbles.map(b => b.color).filter(c => c)))
        : ALL_COLORS;
if (isLoadingSave) {
        refreshFavicon();
        return;
    }
    // If current is missing/invalid, fix it
    if (!currentBall || !pool.includes(currentBall)) {
        currentBall = pool[Math.floor(Math.random() * pool.length)];
    }

    // Only roll next when requested OR if next is invalid
    if (rollNext || !nextBall || !pool.includes(nextBall)) {
        nextBall = pool[Math.floor(Math.random() * pool.length)];
    }

    refreshFavicon();
}

function swapBubbles() { [currentBall, nextBall] = [nextBall, currentBall]; sounds.play('swap'); refreshFavicon(); stats.bubblesSwapped++; saveStats();}
function triggerConfetti() { for(let i=0; i<50; i++) confetti.push({ x: 220, y: 300, vx: (Math.random()-0.5)*10, vy: (Math.random()-0.5)*10, color: ALL_COLORS[Math.floor(Math.random()*6)], life: 1.0 }); }
function updatePaletteUI() {
    const p = document.getElementById('colorPalette');
    p.innerHTML = '';

    // show "√ò" first, then normal colors
    const palette = [null, ...ALL_COLORS];

    palette.forEach(c => {
        const b = document.createElement('div');
        b.className = 'palette-btn' + (c === selectedColor ? ' active' : '');

        if (c === null) {
            b.style.background = "transparent";
            b.style.border = "2px dashed white";
            b.style.display = "inline-flex";
            b.style.alignItems = "center";
            b.style.justifyContent = "center";
            b.style.color = "white";
            b.style.fontWeight = "bold";
            b.innerText = "√ò";
            b.title = "Colorless bubble";
        } else {
            b.style.backgroundColor = c;
            b.title = c;
        }

        b.onclick = () => {
            selectedColor = c;     // ‚úÖ can be null
            updatePaletteUI();
        };

        p.appendChild(b);         // ‚úÖ IMPORTANT
    });
}
    function saveGame(isAuto = false, forceSave = false) {
    
    if (gameOver) return;

    if (isCampaignMode) {
        alert("Cannot create a save file in campaign mode.");
        return;
    }

    if (isPlaytesting) {
        alert("Cannot create a save file in playtest mode.");
        return;
    }

    const ts = getSaveTimestamp();

    const saveData = {
    _metadata: {
        timestamp: ts.readable,
        epoch: ts.epoch,
        gameType:
            (mode === 'custom' || isPlaytesting) ? "CUSTOM" :
            isCampaignMode ? "CAMPAIGN" :
            "PUZZLE",
        saveMethod: isAuto ? "AUTO" : "MANUAL"
    },

    mode,
    level: (mode === 'custom' || isPlaytesting) ? "CUSTOM LEVEL" : level,
    levelName: (mode === 'custom' || isPlaytesting) ? customLevelName : null,
    authorName: (mode === 'custom' || isPlaytesting) ? customAuthorName : null,

    // üìä CORE STATS (ordered)
    score,
	perfect_streak: perfectStreak,
    lives: lives,
    ammo: (mode === 'custom' || isPlaytesting)
        ? parseInt(document.getElementById('customAmmoInput')?.value) || ammo
        : ammo,
    progress: (mode === 'custom' && !isPlaytesting)
        ? "0.0%"
        : getProgress(),

    // ü´ß GAME STATE
    bubbles,

    currentBubble: currentBall ?? null,
    nextBubble: nextBall ?? null
};


    const blob = new Blob(
        [JSON.stringify(saveData, null, 2)],
        { type: 'text/plain' }
    );

    const a = document.createElement('a');

    if (mode === 'custom' || isPlaytesting) {
        const safeLevel = (customLevelName || "Untitled").replace(/[\\\/:*?"<>|]/g, "_");
        const safeAuthor = (customAuthorName || "Unknown").replace(/[\\\/:*?"<>|]/g, "_");
        a.download = `customModeLevel_${safeLevel}_${safeAuthor}.bubblesav`;
    } else {
        const prefix = isAuto ? "(AUTOSAVE) " : "";
        a.download = `${prefix}puzzleModeLevel_${level}.bubblesav`;
    }

    a.href = URL.createObjectURL(blob);
    a.click();
}
    function getSaveTimestamp() {
    const d = new Date();

    const pad = n => n.toString().padStart(2, '0');

    // ----- DAY & MONTH NAMES -----
    const days = [
        "Sunday", "Monday", "Tuesday", "Wednesday",
        "Thursday", "Friday", "Saturday"
    ];

    const months = [
        "January", "February", "March", "April",
        "May", "June", "July", "August",
        "September", "October", "November", "December"
    ];

    const dayName = days[d.getDay()];
    const day = d.getDate();
    const monthName = months[d.getMonth()];
    const year = d.getFullYear();

    // ----- ORDINAL SUFFIX -----
    let suffix = "th";
    if (day % 10 === 1 && day !== 11) suffix = "st";
    else if (day % 10 === 2 && day !== 12) suffix = "nd";
    else if (day % 10 === 3 && day !== 13) suffix = "rd";

    // ----- 12-HOUR TIME -----
    let h = d.getHours();
    const ampm = h >= 12 ? "PM" : "AM";
    h = h % 12;
    if (h === 0) h = 12;

    const m = pad(d.getMinutes());
    const s = pad(d.getSeconds());

    // ----- UTC OFFSET (+HHMM / -HHMM) -----
    const offsetMinutes = -d.getTimezoneOffset();
    const sign = offsetMinutes >= 0 ? "+" : "-";

    const abs = Math.abs(offsetMinutes);
    const oh = pad(Math.floor(abs / 60));
    const om = pad(abs % 60);

    const offset = `${sign}${oh}${om}`;

    return {
        readable:
            `${dayName}, ${day}${suffix} ${monthName} ${year} ` +
            `${h}:${m}:${s} ${ampm} ${offset}`,
        epoch: Math.floor(d.getTime() / 1000)
    };
}
    function openCustomSavePopup() {
    
        if (bubbles.length === 0) {
        alert("Add some bubbles in the canvas first!");
        return;
    }

    if (bubbles.length < 3) {
        alert("Add at least 3 bubbles on to the canvas.");
        return;
    }

    // üö´ NEW CHECK ‚Äî colorless on top row
    const hasColorlessTopRow = bubbles.some(b => b.row === 0 && !b.color);
    if (hasColorlessTopRow) {
        alert("Don't put the colourless bubbles on the top row.");
        return;
    }

    // üö® existing floating-bubble check
    const hasFloating = bubbles.some(b => !hasAtLeastOneConnection(b));
    if (hasFloating) {
        alert("Connect one of the floating bubbles to another bubble.");
        return;
    }
        // üö´ Block inaccessible layouts (sealed by colourless bubbles)
if (!hasReachableColoredBubble()) {
    alert("This level has no reachable bubbles. Remove or reposition colourless bubbles.");
    return;
}
        if (!isCustomMode) {
        saveGame(); // normal save outside editor
        return;
    }

    document.getElementById('customSavePopup').style.display = 'flex';

    // optional: prefill last values
    document.getElementById('levelNameInput').value = customLevelName || "";
    document.getElementById('authorNameInput').value = customAuthorName || "";
}
function confirmCustomSave() {
    customLevelName = (document.getElementById('levelNameInput')?.value || "").trim();
    customAuthorName = (document.getElementById('authorNameInput')?.value || "").trim();

    if (!customLevelName || !customAuthorName) {
        alert("Enter both Level Name and Author Name.");
        return;
    }

    const popup = document.getElementById('customSavePopup');
    if (popup) popup.style.display = 'none';

    // IMPORTANT: forceSave=true so it doesn't reopen the popup
    saveGame(false, true);
}
function handleLoadClick() {
    if (gameOver) return;
    if (isCampaignMode) {
    alert("Cannot load a save file in campaign mode.");
    return;
}


    if (isPlaytesting) {
            alert("Cannot load a save file in playtest mode.");
            return;
        }
        document.getElementById('fileInput').click();
    }

function loadGame(e) {
    const file = e.target.files[0];
    if (!file) return;
    

    const reader = new FileReader();
    isLoadingSave = true;

    reader.onload = (ev) => {
        const s = JSON.parse(ev.target.result);

        // -----------------------------
        // Restore basic metadata
        // -----------------------------
        customLevelName = s.levelName || "";
        customAuthorName = s.authorName || "";

        // -----------------------------
        // CUSTOM LEVEL LOAD
        // -----------------------------
        if (s.level === "CUSTOM LEVEL") {

            enterCustomEditor();

            bubbles = [];
            s.bubbles.forEach(b => {
                const co = getGridCoords(b.row, b.col);
                const nb = {
                    x: co.x,
                    y: co.y,
                    row: b.row,
                    col: b.col
                };
                if (b.color) nb.color = b.color;
                bubbles.push(nb);
            });

            ammo = s.ammo ?? 40;
            document.getElementById('customAmmoInput').value = ammo;

            // progress is irrelevant in editor
            loadedProgressOverride = null;

            isLoadingSave = false;
            updateAmmo(false);
            refreshFavicon();
            return;
        }

        // -----------------------------
        // PUZZLE MODE LOAD
        // -----------------------------

        // Restore level & score FIRST
        level = s.level ?? 1;
        score = s.score ?? 0;
        lives = s.lives ?? 5;
updateLivesUI();


        // Capture saved progress AS-IS (string like "12.1%")
        if (typeof s.progress === "string") {
            loadedProgressOverride = s.progress;
        } else {
            loadedProgressOverride = null;
        }

        // Start game WITHOUT resetting
        startMode('puzzle', true);

        // Rebuild bubbles AFTER startMode
        bubbles = [];
        s.bubbles.forEach(b => {
            const co = getGridCoords(b.row, b.col);
            const nb = {
                x: co.x,
                y: co.y,
                row: b.row,
                col: b.col
            };
            if (b.color) nb.color = b.color;
            bubbles.push(nb);
        });

        // Restore shooter state
        ammo = s.ammo ?? ammo;
		perfectStreak = s.perfect_streak ?? 0;
        currentBall = s.currentBubble ?? currentBall;
        nextBall = s.nextBubble ?? nextBall;

        // IMPORTANT:
        // Do NOT recompute initialBubbleCount here
        // Do NOT touch progress math

        isLoadingSave = false;

        // Force UI refresh
        updateProgressBar();
        updateAmmo(false);
        refreshFavicon();
    };

    reader.readAsText(file);
    event.target.value = "";
}
function closeCustomSavePopup() {
    const popup = document.getElementById('customSavePopup');
    if (popup) popup.style.display = 'none';
}
    const SFX_TYPES = [
    'shoot',
    'pop',
    'bounce',
    'place',
    'swap',
    'fall',
    'win',
    'fail',
   'panic',
    'tick',
    'heartbeat'
];

function openSfxMenu() {
    const menu = document.getElementById('sfxMenu');
    const list = document.getElementById('sfxList');
    list.innerHTML = '';

    SFX_TYPES.forEach(type => {
        const row = document.createElement('div');
        row.style.margin = '8px 0';
        row.style.display = 'flex';
        row.style.justifyContent = 'space-between';
        row.style.alignItems = 'center';

        const label = document.createElement('span');
        label.innerText = type.toUpperCase();
        label.style.flex = '1';

        const btn = document.createElement('button');
        btn.innerText = '‚ñ∂ PLAY';
        btn.style.background = '#00ffcc';
        btn.style.color = '#000';
        btn.style.border = 'none';
        btn.style.padding = '5px 10px';
        btn.style.borderRadius = '5px';
        btn.onclick = () => sounds.play(type);

        row.appendChild(label);
        row.appendChild(btn);
        list.appendChild(row);
    });

    menu.style.display = 'flex';
}

function closeSfxMenu() {
    document.getElementById('sfxMenu').style.display = 'none';
}
    function resetProgressBar() {
    loadedProgressOverride = null;
    initialBubbleCount = 0;

    document.getElementById('progressBar').style.width = "0%";
    document.getElementById('percentText').innerText = "0.0%";

    document.getElementById('progressContainer').style.display = "none";
    document.getElementById('percentText').style.display = "none";
}
function clearEditor() { if(confirm("Clear level?")) bubbles = []; }
function exitToMenu() { setBrowserTitle("‚≠ê SK's Bubble Shooter"); gameRunning = false; document.getElementById('mainMenu').style.display = 'block';  document.getElementById('gameUI').style.display = 'none'; document.getElementById('customUI').style.display = 'none'; document.getElementById('mobileControls').style.display = 'none'; canvas.style.display = 'none'; perfectStreak = 0;     // ‚úÖ Reset run-state
    lives = DEFAULT_LIVES;
    updateLivesUI(); updateStatsBoard(); updateFavicon(); resetProgressBar(); addSfxButtonToMenu();}
updateStatsBoard();
	updateFavicon();
addSfxButtonToMenu();

</script>
    <div id="customSavePopup" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,0.85);z-index:9999;align-items:center;justify-content:center;">
  <div style="background:#222;padding:25px;border-radius:12px;border:2px solid #00ffcc;text-align:center;">
    <h2 style="color:#00ffcc;">Save Custom Level</h2>

    <input id="levelNameInput" placeholder="Level Name"
      style="display:block;margin:10px auto;padding:8px;width:220px;background:#000;color:#00ffcc;border:1px solid #333;">

    <input id="authorNameInput" placeholder="Author Name"
      style="display:block;margin:10px auto;padding:8px;width:220px;background:#000;color:#00ffcc;border:1px solid #333;">

    <button onclick="confirmCustomSave()" style="margin-top:10px;background:#00ffcc;color:#000;font-weight:bold;">
      CONFIRM SAVE
    </button>
  </div>
        <button onclick="closeCustomSavePopup()" 
    style="background:#ff5555;color:#fff;font-weight:bold; padding:8px 18px;">
    CANCEL
  </button>
</div>
</div>
    <div id="sfxMenu" style="
display:none;
position:fixed;
inset:0;
background:rgba(0,0,0,0.9);
z-index:9999;
align-items:center;
justify-content:center;
">
  <div style="
    background:#222;
    padding:25px;
    border-radius:12px;
    border:2px solid #00e5ff;
    width:320px;
    text-align:center;
    color:white;
  ">
    <h2 style="color:#00e5ff;">SFX Tester</h2>

    <div id="sfxList" style="margin-top:15px;"></div>

    <button onclick="closeSfxMenu()" style="
      margin-top:20px;
      background:#ff5555;
      padding:8px 20px;
      border:none;
      border-radius:6px;
      color:white;
      font-weight:bold;
    ">CLOSE</button>
  </div>
</div>
</body>
</html>
<!--Note: This game was made with a help of ChatGPT and Gemini. (Don't judge me.) lol-->










